<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
