<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode: 647. Palindromic Substrings]]></title>
    <url>%2F2019%2F09%2F11%2FLeetCode-647-Palindromic-Substrings%2F</url>
    <content type="text"><![CDATA[题目描述 Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: 123Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: 123Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. 这题的第一反应就是用动态规划做。dp[i][j]表示从s[i]-s[j]的字符串是否为回文，如果为回文，则为1，反之0. 状态转移表达式为： dp[i][j]=\begin{cases}1&\ s[i]=s[j]\bigwedge(j-i=1\bigvee dp[i+1][j-1]=1)\\0&\ else \end{cases}初始化为对任何i，$dp[i][i] =1$。最后，只需要计算出dp中有多少个1即可。 代码实现 12345678910111213141516171819202122232425class Solution &#123;public: int countSubstrings(string s) &#123; int result = 0; vector&lt;vector&lt;int&gt;&gt; dp(s.length(), vector&lt;int&gt;(s.length())); for (int i=0; i&lt;s.length(); i++) &#123; dp[i][i] = 1; result += 1; &#125; for (int j=1; j &lt; s.length(); j++) &#123; for (int i=0; i&lt;s.length(); i++) &#123; if (i+j &gt;= s.length()) break; if (j == 1 &amp;&amp; s[i] == s[i+j]) &#123; dp[i][i+j] = 1; result += 1; &#125; else if (dp[i+1][i+j-1] == 1 &amp;&amp; s[i] == s[i+j]) &#123; dp[i][i+j] = 1; result += 1; &#125; &#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 316. Remove Duplicate Letters]]></title>
    <url>%2F2019%2F09%2F10%2FLeetCode-316-Remove-Duplicate-Letters%2F</url>
    <content type="text"><![CDATA[题目描述 Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: 12Input: &quot;bcabc&quot;Output: &quot;abc&quot; Example 2: 12Input: &quot;cbacdcbc&quot;Output: &quot;acdb&quot; 原本还在想有没有什么更巧妙的方法，最后失败了hhh，果然是一个hard题 所以这道题目还是采取一种类似暴力搜索的方法，以题目的某个case &quot;bbcaac&quot;为例。 我的做法是使用了result来存储结果，一开始为一个空的字符串，每次决定一个字符的位置之后，讲字符加到result之后；另外我们用map来存储信息，map保存了所有没有被放入result中的字符，其中键为字符，value为一个vector&lt;int&gt;，它存放了所有字符出现的位置（index）。 上述例子的具体存放方式如下： 'a': [3, 4]\\ 'b': [0, 1]\\ 'c': [2, 5]我的解的核心思想是，一个字符x如果能从map的key中放入result的结尾，那么map的剩下的所有key都至少有一个值在map[x][0]之后。因为map存放的是所有没有纳入result的字符，如果这些字符在map中对应的值里没有比map[x][0]大的，说明这些字符都排在x之前，那么它们应该早就放到result中了。 这个从map.begin()的iterator开始遍历（由于是使用STL的map进行存储，map的实现是一个红黑树，其保存了key的相对位置信息，所以可以用iterator实现lexicographical），看每个值（vector）的第一个元素，比如$’a’$的第一个元素就是3，说明第一个a出现在3的位置。这个时候，就需要检查其他所有的iterator的最后一个元素，如果说某个元素的最后一个值小于了3（比如b），就说明它在字符串中，所有的b都在3之前就出现了，a之后并没有b，但是，由于map存储的是所有没有在result中的结果，所以b还没有被放到result中去，可是a之后又没有b了，这样就造成了矛盾，说明a目前不能放到result里。 接着来看b。map[&#39;b&#39;][0]为0，说明第一个b出现在0处，此时是成立的，因为map[&#39;a&#39;]和map[&#39;c&#39;]中都有在0之后的值，说明a和c都至少有一个在0处的b的后面，所以就把b放入result，并且把b这个key从map中删除。 接着，重新开始遍历字典，从a开始。现在3位置的a可以放入，因为map只剩下c了，c可以在a的后面，所以把a从map的key中取出，放入result。最后只剩下c了，就把c从map的key中取出，放入result。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: string removeDuplicateLetters(string s) &#123; map&lt;char, vector&lt;int&gt;&gt; indexMap; string result = ""; for (int i = 0; i&lt;s.length(); i++)&#123; if (indexMap.find(s[i]) == indexMap.end()) &#123; indexMap[s[i]] = &#123;i&#125;; &#125; else &#123; indexMap[s[i]].push_back(i); &#125; &#125; while (!indexMap.empty()) &#123; for (auto it = indexMap.begin(); it != indexMap.end();)&#123; bool isValid = true; for (auto it2 = indexMap.begin(); it2 != indexMap.end(); it2++) &#123; if (it-&gt;first == it2-&gt;first) &#123; continue; &#125; if (it2-&gt;second[it2-&gt;second.size()-1] &lt; it-&gt;second[0]) &#123; isValid = false; &#125; &#125; if (isValid) &#123; result += it-&gt;first; for (auto it2 = indexMap.begin(); it2 != indexMap.end(); it2++) &#123; while (it2-&gt;second[0] &lt; it-&gt;second[0]) it2-&gt;second.erase(it2-&gt;second.begin()); &#125; indexMap.erase(it); it = indexMap.begin(); &#125; else &#123; it++; &#125; &#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 557. Reverse Words in a String III]]></title>
    <url>%2F2019%2F09%2F10%2FLeetCode-557-Reverse-Words-in-a-String-III%2F</url>
    <content type="text"><![CDATA[题目描述 Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: 12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 这题需要先根据&#39; &#39;来切分字符串，然后对每一个切分后的元素进行反转，反转可以用reverse(s.begin(), s.end())。 切分字符串的时候，我使用了字符串流，然后使用getline函数来进行切割。 代码实现 123456789101112131415161718192021222324252627282930class Solution &#123;private: vector&lt;string&gt; split(string s, char d)&#123; vector&lt;string&gt; result; stringstream input(s); string tmp; while (getline(input, tmp, d)) &#123; if (tmp == "") &#123; continue; &#125; result.push_back(tmp); &#125; return result; &#125;public: string reverseWords(string s) &#123; vector&lt;string&gt; split_s = split(s, ' '); string result = ""; for (int i=0; i &lt; split_s.size(); i++) &#123; reverse(split_s[i].begin(), split_s[i].end()); result = result + split_s[i]; if (i &lt; split_s.size()-1) &#123; result += " "; &#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 567. Permutation in String]]></title>
    <url>%2F2019%2F09%2F09%2FLeetCode-567-Permutation-in-String%2F</url>
    <content type="text"><![CDATA[题目描述 Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string. Example 1: 123Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;Output: TrueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;). Example 2: 12Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;Output: False 使用一个hashMap存放s1中的字符，用字符作为键，出现的次数作为值。 然后使用一个长度为s1.length()的窗口在s2上滑动，并且记录窗口中的字符串的所有字符组成的hashMap2。在滑动的同时对hashMap2进行动态的更改，然后每一次滑动都进行一次比较，如果hashMap与hashMap2中的键和值都相同，则返回True，如果到窗口滑动结束后都没有匹配，则返回False。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;private: bool checkMap(unordered_map&lt;char, int&gt; map1, unordered_map&lt;char, int&gt; map2) &#123; for (auto it = map1.begin(); it != map1.end(); it++) &#123; char item = it-&gt;first; if (map2.find(item) == map2.end() || map2[item] != map1[item]) &#123; return false; &#125; &#125; return true; &#125;public: bool checkInclusion(string s1, string s2) &#123; if (s1.length() &gt; s2.length()) &#123; return false; &#125; unordered_map&lt;char, int&gt; map1; unordered_map&lt;char, int&gt; map2; for (int i=0; i&lt;s1.length(); i++) &#123; if (map1.find(s1[i]) == map1.end()) &#123; map1[s1[i]] = 1; &#125; else &#123; ++map1[s1[i]]; &#125; &#125; for (int i=0; i&lt;s1.length(); i++) &#123; if (map2.find(s2[i]) == map2.end()) &#123; map2[s2[i]] = 1; &#125; else &#123; ++map2[s2[i]]; &#125; &#125; for (int i=s1.length(); i&lt;=s2.length(); i++) &#123; if (checkMap(map1, map2)) &#123; return true; &#125; if (i == s2.length()) &#123; return false; &#125; if (map2[s2[i-s1.length()]] &gt; 1) &#123; --map2[s2[i-s1.length()]]; &#125; else &#123; map2.erase(s2[i-s1.length()]); &#125; if (map2.find(s2[i]) != map2.end()) &#123; ++map2[s2[i]]; &#125; else &#123; map2[s2[i]] = 1; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 377. Combination Sum IV]]></title>
    <url>%2F2019%2F09%2F09%2FLeetCode-377-Combination-Sum-IV%2F</url>
    <content type="text"><![CDATA[题目描述 Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 一开始以为是一道简单的dfs的题目，结果暴力做直接TLE。 这题应该用DP来做，令dp[i]为这个序列和为i的排列个数。状态转移方程为: dp_{i} = \sum_jdp_{i-j}\\j\in nums意思就是$j$是nums中的数字，这个dp的规律就是对于目标和target，它是所有和为target-j的可能性之和，相当于在所有target-j的目标最后加上了j作为一个新的排列。 代码实现 12345678910111213141516class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;unsigned long&gt; dp(target+1, 0); dp[0] = 1; for (int i=1; i&lt;=target; i++) &#123; for (auto it = nums.begin(); it != nums.end(); it++) &#123; if (i - *it &gt;= 0) &#123; dp[i] += dp[i - *it]; &#125; &#125; &#125; return dp[target]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 668. Kth Smallest Number in Multiplication Table]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-668-Kth-Smallest-Number-in-Multiplication-Table%2F</url>
    <content type="text"><![CDATA[题目描述 Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table. Example 1: 123456789Input: m = 3, n = 3, k = 5Output: Explanation: The Multiplication Table:1 2 32 4 63 6 9The 5-th smallest number is 3 (1, 2, 2, 3, 3). Example 2: 12345678Input: m = 2, n = 3, k = 6Output: Explanation: The Multiplication Table:1 2 32 4 6The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6). 真的是挺难的一道二分查找题，主要也是想不到可以这么做。 令left = 1,right=m*n得到mid然后去计算multiplication table中小于mid的个数cnt。如果小于，则令right=mid否则则left=mid+1，最后返回left。 这里可以不用考虑left是否在table中，因为这样做的话是肯定在table里的。因为left一定能找到一个在table中的数字，满足在table中的条件，如果找到了，那么left就不会有变化了，接下来都是right在进行收敛。另外，这里不能用right=mid-1，是因为mid得到的cnt是一个大于等于实际k的值(比如第一个例子，mid为6的时候，cnt为8，如果在k=7点时候直接right=mid-1的话，会永远找不到值)，所以right=mid，而在left=mid+1则没有问题。 代码实现 1234567891011121314151617181920class Solution &#123;public: int findKthNumber(int m, int n, int k) &#123; int left = 1; int right = n*m; while (left &lt; right) &#123; int mid = (right - left) / 2 + left; int cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; cnt += min(mid/i, n); &#125; if (cnt &lt; k) &#123; left = mid+1; &#125; else &#123; right = mid; &#125; &#125; return left; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 337. House Robber III]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-337-House-Robber-III%2F</url>
    <content type="text"><![CDATA[题目描述 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 12345678910Input: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: 12345678910Input: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1Output: 9Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. 这题是小偷的第三题，前两题因为都是一个数列，所以很容易就可以用DP做。 但是这题所有的路线是用二叉树来表示的，因此首选思路还是DFS。 对于每一个节点，它的偷窃的最大值只有两种情况，第一种是自己的两个子节点们的返回值之和，还有一种是自己的值加上自己的孙子节点们的返回值之和，所以dfs还是比较好实现的。 有一点要注意的是，需要用一个hashMap来存储每个节点的返回值，因为在进行dfs的时候，会重复查找节点的值，如果没有一个hashMap来存储数据的话，会TLE。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;private: unordered_map&lt;TreeNode*, int&gt; hashMap; int subTreeRob(TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; if (hashMap.find(root) != hashMap.end())&#123; return hashMap[root]; &#125; int result = 0; if (root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL) &#123; result = max(root-&gt;val + subTreeRob(root-&gt;left-&gt;left) + subTreeRob(root-&gt;left-&gt;right) + subTreeRob(root-&gt;right-&gt;left) + subTreeRob(root-&gt;right-&gt;right), subTreeRob(root-&gt;left) + subTreeRob(root-&gt;right)); &#125; else if (root-&gt;left != NULL) &#123; result = max(root-&gt;val + subTreeRob(root-&gt;left-&gt;left) + subTreeRob(root-&gt;left-&gt;right), subTreeRob(root-&gt;left)); &#125; else if (root-&gt;right != NULL)&#123; result = max(root-&gt;val + subTreeRob(root-&gt;right-&gt;left) + subTreeRob(root-&gt;right-&gt;right), subTreeRob(root-&gt;right)); &#125; else &#123; result = root-&gt;val; &#125; hashMap[root] = result; return result; &#125;public: int rob(TreeNode* root) &#123; return subTreeRob(root); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 378. Kth Smallest Element in a Sorted Matrix]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix%2F</url>
    <content type="text"><![CDATA[题目描述 Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. 这题我想不到什么更好的方法，并没有用到行列之间的有序性来做，只是维持了一个最大堆（优先序列）去做，不过OJ还是可以通过的。 代码实现 123456789101112131415class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; priority_queue&lt;int&gt; priorityQueue; for(int i = 0; i &lt; matrix.size(); i++) &#123; for(int j=0; j &lt; matrix[0].size(); j++) &#123; priorityQueue.push(matrix[i][j]); if (priorityQueue.size() &gt; k) &#123; priorityQueue.pop(); &#125; &#125; &#125; return priorityQueue.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 480. Sliding Window Median]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-480-Sliding-Window-Median%2F</url>
    <content type="text"><![CDATA[题目描述 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: 12[2,3,4]` , the median is `3[2,3]`, the median is `(2 + 3) / 2 = 2.5 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. 12345678Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:You may assume k is always valid, ie: k is always smaller than input array’s size for non-empty array. 这题和之前的着sliding window中的最大值不一样，之前只需要维护好最大值就可以了，但是这里还是需要维护整个数组的顺序。在这个时候，效率最高的是multiset，本质是一个红黑树，插入、查找、删除的时间复杂度均为O(logn)。 在这里我们需要用一个iterator确定中间值的位置，可以使用auto it = next(multiset, k/2)实现。在确定了初始中间iterator的位置后，每次向右滑动时，都要将新元素加入multiset，同时比较这个值和*iterator的大小，如果比较小，那么它一定排在iterator之前，为了让iterator仍然指向中间的位置，我们需要iterator--（这里不能取等，因为相同的元素在multiset中，新的排在旧的之后） 。同时，还需要将window最左边的元素erase出multiset，如果这个值不大于*iterator，那么需要iterator++（这里需要去等号，因为等会删除的时候，对于任何不大于*iterator的*it，it一定在iterator前） 最后要在multiset中删除元素，multiset不能直接用erase，不然会删除所有相同的元素，而应该使用multiset.find(n)找到第一个it，然后用it删除。最后时间复杂度为O(nlogk) 代码实现 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;double&gt; result; multiset&lt;double&gt; window(nums.begin(), nums.begin()+k); auto midIterator = next(window.begin(), k/2); for (int i = k; i &lt;= nums.size(); i++) &#123; if (k%2) result.push_back(*midIterator); else result.push_back((*midIterator + *prev(midIterator))/2); if (i == nums.size()) break; window.insert(nums[i]); if (nums[i] &lt; *midIterator) midIterator--; if (nums[i-k] &lt;= *midIterator) midIterator++; auto pos = window.find(nums[i-k]); window.erase(pos); &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 232. Implement Queue using Stacks]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-232-Implement-Queue-using-Stacks%2F</url>
    <content type="text"><![CDATA[题目描述 Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use only standard operations of a stack — which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 使用stack模拟queue，对于peek和pop操作需要另外一个stack协助完成，原stack进行pop操作的时候另一个stack进行push来保存所有元素。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue &#123;private: stack&lt;int&gt; _stack;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; this-&gt;_stack.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; stack&lt;int&gt; tmp; assert (!this-&gt;_stack.empty()); int popNum = 0; while (!this-&gt;_stack.empty()) &#123; popNum = this-&gt;_stack.top(); this-&gt;_stack.pop(); if (!this-&gt;_stack.empty()) &#123; tmp.push(popNum); &#125; &#125; while (!tmp.empty()) &#123; this-&gt;_stack.push(tmp.top()); tmp.pop(); &#125; return popNum; &#125; /** Get the front element. */ int peek() &#123; stack&lt;int&gt; tmp; int topNum = 0; while (!this-&gt;_stack.empty()) &#123; tmp.push(this-&gt;_stack.top()); this-&gt;_stack.pop(); &#125; topNum = tmp.top(); while (!tmp.empty()) &#123; this-&gt;push(tmp.top()); tmp.pop(); &#125; return topNum; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return this-&gt;_stack.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 445. Add Two Numbers II]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[题目描述 You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 这里需要对两个链表进行加法，首先需要将列表进行反转，然后从表头进行链表的遍历。然后对两个链表进行同时从头到尾遍历。每一次遍历后将值相加，然后保存到一个新的节点中，然后两个节点都向后移一位。最后要注意两个表都遍历到头了以后，如果carry为1，还需要额外生成一个节点连接到结果的最后。 在返回前，需要对结果再进行一次反转。 123456789101112131415161718192021222324252627282930313233343536class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def reverseList(l:'ListNode') -&gt; 'ListNode': if l == None: return l lastNode = None while l.next != None: nextL = l.next l.next = lastNode lastNode = l l = nextL l.next = lastNode return l reversedL1 = reverseList(l1) reversedL2 = reverseList(l2) start = ListNode(0) last = start carry = 0 while reversedL1 != None or reversedL2 != None: val1 = 0 if reversedL1 == None else reversedL1.val val2 = 0 if reversedL2 == None else reversedL2.val val = val1 + val2 + carry carry = val // 10 val = val % 10 last.next = ListNode(val) last = last.next reversedL1 = None if reversedL1 == None else reversedL1.next reversedL2 = None if reversedL2 == None else reversedL2.next if carry == 1: last.next = ListNode(1) return reverseList(start.next)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 350. Intersection of Two Arrays II]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-350-Intersection-of-Two-Arrays-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] Example 2: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 这里我使用了一个dict来存放nums1中的数字，其中key为nums1的数字，value为该key出现在nums1中的次数。然后遍历nums2，并且在dict中查找是否出现过这个key，如果有，则给该key的value-=1，并且在result中加入一次这个key，如果value变成了0，就pop这个key。 代码实现 1234567891011121314151617class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic1 = &#123;&#125; for num in nums1: if num in dic1.keys(): dic1[num] += 1 else: dic1[num] = 1 result = [] for num in nums2: if num in dic1.keys(): dic1[num] -= 1 result.append(num) if dic1[num] == 0: dic1.pop(num) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 349. Intersection of Two Arrays]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-349-Intersection-of-Two-Arrays%2F</url>
    <content type="text"><![CDATA[题目描述 Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2] Example 2: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] Note: Each element in the result must be unique. The result can be in any order. 用python的set投机取巧了一下hhh 代码实现 12345class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: s1 = set(nums1) s2 = set(nums2) return list(s1 &amp; s2)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 450. Delete Node in a BST]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-450-Delete-Node-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述 Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). Example: 1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 这题需要在二分查找树中删除节点。 在找到该节点位置之后，二分查找树删除节点的思路为： 如果该节点没有子节点，则直接删除 如果该节点有左子节点，就找左子树的最大值替换该节点的值，并且删除左子树中的最大节点 如果该节点有右子节点，就找右子树的最小值替换该节点的值，并且删除右子树中的最小节点 我使用了循环而非递归来做，所以代码看起来会比较繁琐，但是效率会比递归的更高。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: """ :type root: TreeNode :type key: int :rtype: TreeNode """ if root == None: return root node = root lastNode = None while node.val != key: if node.val &gt; key and node.left != None: lastNode = node node = node.left elif node.val &lt; key and node.right != None: lastNode = node node = node.right else: break if node.val != key: return root if node.left == None and node.right == None: if lastNode == None: return None if lastNode.left != None and lastNode.left.val == key: lastNode.left = None else: lastNode.right = None elif node.left != None: leftMax = node.left leftMaxLast = node while leftMax.right != None: leftMaxLast = leftMax leftMax = leftMax.right if leftMaxLast != node: leftMaxLast.right = leftMax.left else: leftMaxLast.left = leftMax.left node.val = leftMax.val else: rightMin = node.right rightMinLast = node while rightMin.left != None: rightMinLast = rightMin rightMin = rightMin.left if rightMinLast != node: rightMinLast.left = rightMin.right else: rightMinLast.right = rightMin.right node.val = rightMin.val return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 237. Delete Node in a Linked List]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述 Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list — head = [4,5,1,9], which looks like following: Example 1: 123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2: 123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. 题目描述有点问题，题目的原意是给一个node，直接在该node存在的list中删除这个node，因为不知道父节点的地址，所以只需要将node的val改成node.next的val，然后把node.next设置成node.next.next就可以了。 1234567891011121314# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 653. Two Sum IV - Input is a BST]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述 Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 使用中序遍历整个数，可以得到BST所有元素的从小到大的排列的list，然后对有序list找两个和为target。 对数组的操作比较简单，设置两个index，为数组的最左边和最右边的index，然后把两个元素加起来，如果和大于target，就右边index-=1，小于target就左边index+=1，直到和为target，返回True，或者左边的index大于右边index，返回False。 代码实现 12345678910111213141516171819202122class Solution: def findTarget(self, root: TreeNode, k: int) -&gt; bool: def dfs(root): if root == None: return dfs(root.left) allNums.append(root.val) dfs(root.right) allNums = [] dfs(root) leftIndex = 0 rightIndex = len(allNums) - 1 while leftIndex &lt; rightIndex: if allNums[leftIndex] + allNums[rightIndex] &lt; k: leftIndex += 1 elif allNums[leftIndex] + allNums[rightIndex] &gt; k: rightIndex -= 1 else: return True return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 714. Best Time to Buy and Sell Stock with Transaction Fee]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee%2F</url>
    <content type="text"><![CDATA[题目描述 Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 1234Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 这题有了309铺路之后就显得很好做，也是使用状态机来表示，无非这里只有两个状态（没有了$S_{2}$） $S_{0}$是未买入时的状态，$S_{1}$为买入后的状态，状态转移方程为： S_{0}[i]=\max(S_{0}[i-1], S_{1}[i-1]+price[i]-fee) \\ S_{1}[i]=\max(S_{1}[i-1], S_{0}[i-1]-price[i])代码实现 12345678910111213class Solution: def maxProfit(self, prices: 'list[int]', fee: 'int') -&gt; 'int': if len(prices) == 0: return 0 dp = [[0] * len(prices) for _ in range(2)] dp[1][0] = -prices[0] for i in range(1, len(prices)): dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] + prices[i] - fee) dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] - prices[i]) return dp[0][-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 309. Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2F2019%2F09%2F06%2FLeetCode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown%2F</url>
    <content type="text"><![CDATA[题目描述 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: 123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 我好菜啊，dp自己怎么都想不出… 这题可以用一种状态机的思路来做，具体思路如下： 其中$S_{0}$表示没有买入的时候的状态，$S_{1}$表示买入后持有的状态，$S_{2}$表示刚刚卖出的时候的cool down。状态及可以表示出三个状态的表示过程，通过状态机，我们可以写出三个状态的转移方程： S_{0}[i]=\max(S_{0}[i-1], S_{2}[i-1]) \\ S_{1}[i]=\max(S_{1}[i-1], S_{0}[i-1]-price[i])\\S_{2}[i]=price[i]+S_{1}[i-1]​在最后，$\max(S_{0}[-1], S_{1}[-1], S_{2}[-1])$就是该方案的最大收益。 代码实现 1234567891011121314class Solution: def maxProfit(self, prices: 'list[int]') -&gt; 'int': if len(prices) == 0: return 0 dp = [[0] * len(prices) for _ in range(3)] dp[1][0] = -prices[0] for i in range(1, len(prices)): dp[0][i] = max(dp[0][i - 1], dp[2][i - 1]) dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] - prices[i]) dp[2][i] = prices[i] + dp[1][i - 1] return max(dp[0][-1], dp[1][-1], dp[2][-1])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 283. Move Zeroes]]></title>
    <url>%2F2019%2F09%2F06%2FLeetCode-283-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Example: 12Input: [0,1,0,3,12]Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 题目要求inplace without making a copy对两个索引从左到右进行遍历，第一个索引index1遍历到0元素就停下，然后第二个索引index2继续遍历，直到第一个非零元素且index2&gt;index1就停下，然后交换元素的值即可。 代码实现 1234567891011121314151617181920212223class Solution: def moveZeroes(self, nums: 'list[int]') -&gt; 'None': """ Do not return anything, modify nums in-place instead. """ indexZero = 0 indexNonZero = 0 while True: while indexZero &lt; len(nums): if nums[indexZero] == 0: break indexZero += 1 if indexZero == len(nums): break while indexNonZero &lt; len(nums): if nums[indexNonZero] != 0 and indexNonZero &gt; indexZero: break indexNonZero += 1 if indexNonZero == len(nums): break nums[indexZero] = nums[indexNonZero] nums[indexNonZero] = 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 295. Find Median from Data Stream]]></title>
    <url>%2F2019%2F09%2F06%2FLeetCode-295-Find-Median-from-Data-Stream%2F</url>
    <content type="text"><![CDATA[题目描述 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, 12[2,3,4]`, the median is `3[2,3]`, the median is `(2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: 12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 Hard题。 如果是去使用quick sort维护数组，那么addNum的复杂度为O(nlogn)，查找为O(1)。 但是，这里可以使用一个最大堆存放整个stream的最小的一半数字，用最小堆存放整个stream的最大的一半数字，那么addNum的复杂度就是O(logn)，查找为O(1)，可以极大程度提升性能。 这里要注意的就是如何去维护两个堆中的数字。所以需要对每次addNum的数字与堆顶的数字进行比较和操作。比较简单，在此不加赘述。 代码实现 1234567891011121314151617181920212223242526272829303132import heapqclass MedianFinder: def __init__(self): """ initialize your data structure here. """ self.minheap = [] self.maxheap = [] def addNum(self, num: int) -&gt; None: if (len(self.minheap) + len(self.maxheap)) &amp; 1: if num &lt; self.minheap[0]: heapq.heappush(self.maxheap, -num) else: heapq.heappush(self.minheap, num) top = heapq.heappop(self.minheap) heapq.heappush(self.maxheap, -top) else: if len(self.maxheap) &gt; 0 and num &lt; -self.maxheap[0]: top = -heapq.heappop(self.maxheap) heapq.heappush(self.minheap, top) heapq.heappush(self.maxheap, -num) else: heapq.heappush(self.minheap, num) def findMedian(self) -&gt; float: if (len(self.minheap) + len(self.maxheap)) &amp; 1: return self.minheap[0] else: return (self.minheap[0] - self.maxheap[0])/2]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 239. Sliding Window Maximum]]></title>
    <url>%2F2019%2F09%2F06%2FLeetCode-239-Sliding-Window-Maximum%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Hard题，难点在于O(n)算法的实现。 这里的O(n)需要使用一个可以维持顺序的队列，成为单调队列。该队列中存储了最有可能成为Max的数字，比如对于k=3, nums=[2, 1, 4, 5]来说，一开始的这个队列长度为0，对nums进行从左到右遍历。首先先看第一个元素2，直接进入队列中，然后看第二个元素1，实际上1还是有可能成为Max的数字的，因为当2出列的时候，1就有可能成为最大的数字，因此push进1，单调队列为[2, 1]，接下来是4，由于4比单调队列中的所有数字都大，而且之前的数字出列之前，之前的数字都不可能再成为最大的数字了，因此把单调队列pop两次，再push进4。此时，第一个sliding window的最大值就是最左边的这个元素4。当遍历到5的时候，由于5比4大，而且之后4也不可能成为最大的了，所以就pop出4，push进5. 这里需要注意的就是要检查每一次出sliding window时出去的这个元素是不是单调队列中最大的那个元素，如果是的话，就要把最开头的这个元素pop掉；如果不是，则不用处理，因为它也一定不会存在于单调队列的其他地方中，也不会对之后的结果有任何影响。（这里可能就是hint所说的双向队列deque的体现吧） 代码实现 123456789101112131415161718192021222324class Solution: def maxSlidingWindow(self, nums: 'list[int]', k: 'int') -&gt; 'list[int]': if len(nums) == 0: return [] queue = [] for i in range(k): while queue != [] and nums[i] &gt; queue[-1]: queue.pop() queue.append(nums[i]) result = [queue[0]] for i in range(k, len(nums)): if nums[i - k] == queue[0]: queue.pop(0) while queue != [] and nums[i] &gt; queue[-1]: queue.pop() queue.append(nums[i]) result.append(queue[0]) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 231. Power of Two]]></title>
    <url>%2F2019%2F09%2F04%2FLeetCode-231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[题目描述 Given an integer, write a function to determine if it is a power of two. Example 1: 123Input: 1Output: true Explanation: 20 = 1 Example 2: 123Input: 16Output: trueExplanation: 24 = 16 Example 3: 12Input: 218Output: false 所有2的n次方的数字的二进制表示中，只有一个1，并且该1出现在首位。 因此，该题目就是判断输入的数字的二进制表示中有几个1，如果出现了多个1，那就一定不对。在实现方面，我使用了位运算，不断对输入向右移位，直到出现第一个1为止。这个时候进行判断，如果该数字仍然大于1，则说明这个数字还包含了多个1，因此返回false。另外需要排除0和一切负数的情况。 12345678910111213class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: if n &lt; 1: return False while n &gt; 0: if n &amp; 1 == 1: break n &gt;&gt;= 1 if n &gt; 1: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 230. Kth Smallest Element in a BST]]></title>
    <url>%2F2019%2F09%2F04%2FLeetCode-230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述 Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1: 1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 Example 2: 123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1Output: 3 由于这个是一个二叉搜索树，因此内部的数字已经排列好了，我们只需要通过遍历树去找到第k小的数字。 这里可以用中序遍历的方法，在遍历第k次的时候，该node的val就是所需要求解的值。 12345678910111213141516171819202122class Solution: def __init__(self): self.tmp = 0 self.k = 0 self.result = 0 def traversal(self, root): if root == None: return self.traversal(root.left) self.tmp += 1 if self.tmp == self.k: self.result = root.val self.traversal(root.right) def kthSmallest(self, root: 'TreeNode', k: 'int') -&gt; 'int': self.k = k self.traversal(root) return self.result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 229. Majority Element II]]></title>
    <url>%2F2019%2F09%2F03%2FLeetCode-229-Majority-Element-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: 12Input: [3,2,3]Output: [3] Example 2: 12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 如果要满足O(1)的space complexity的话，这是挺难的一道题。 由于需要找的数字最多只有两个，我们设置两个计数器，分别记录最有可能返回的两个值，以及他们记数的大小。 在遍历的时候，如果遍历到除了这两个数字之外的其他数字，就给他们两个的记述器都减1，如果遍历到与这两个数字相同的数字，就给相同的那个计数器加1.当某个计数器为0的时候，下一次遍历就可以将该计数器所对应的数字记为该新数字。 之所以这样做，是因为我们只需要记录最有可能的数字，如果说遍历到中途，某个数字的计数器变成0了，就说明它在当前的序列里，占比不会超过1/3，所以它一定不可能。 关于这题的理解我也并不是很透彻，已经标注了star 代码实现 123456789101112131415161718192021222324252627282930313233343536class Solution: def majorityElement(self, nums: 'list[int]') -&gt; 'list[int]': num1, num2 = 0, 0 count1, count2 = 0, 0 threshold = len(nums) // 3 for num in nums: if num1 == num: count1 += 1 elif num2 == num: count2 += 1 elif count1 == 0: num1 = num count1 = 1 elif count2 == 0: num2 = num count2 = 1 else: count1 -= 1 count2 -= 1 count1, count2 = 0, 0 for num in nums: if num == num1: count1 += 1 if num == num2: count2 += 1 result = [] if count1 &gt; threshold: result.append(num1) if num2 != num1 and count2 &gt; threshold: result.append(num2) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 228. Summary Ranges]]></title>
    <url>%2F2019%2F09%2F02%2FLeetCode-228-Summary-Ranges%2F</url>
    <content type="text"><![CDATA[题目描述 Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: 123Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range. Example 2: 123Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range. 题目要我们返回所有数字的范围，这些数字已经有序排好，并且没有重复。 这里需要从左向右遍历，当遍历到i，且nums[i] != nums[i-1]+1的时候，i-1就是一个range的右边界，i是下一个边界的左边界。另外需要注意左边界和右边界相同的情况。 为了方便代码的实现，我在输入数组后加入了一个dummy元素，这个元素理论上可以是任何值，它可以让代码更简单，而不需要考虑最后一个值的边界情况。 123456789101112131415161718192021222324class Solution: def summaryRanges(self, nums: 'list[int]') -&gt; 'list[str]': result = [] if len(nums) == 0: return result start = nums[0] if len(nums) == 1: result.append(str(start)) return result nums.append(nums[0]) for i in range(1, len(nums)): if nums[i - 1] == nums[i] - 1: continue else: if start != nums[i - 1]: result.append(str(start) + '-&gt;' + str(nums[i - 1])) else: result.append(str(start)) start = nums[i] return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 42. Trapping Rain Water]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-42-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[题目描述 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 这道题目要计算储水量是多少。对于每一个索引i，它的水量的高度为从左边到i点的最高的墙的高度max( : i)，和从i点到最右边的最高墙的高度max( i: )的最小值，即min( max( : i), max( i: ) ) 对于每个点，找左边墙的最高高度有O(n)算法，即从左向右遍历，并且保存遍历的最大值，该最大值就是每个点的左墙高度，同理找右边墙的最高高度也有O(n)算法。 举个例子，对于[0,1,0,2,1,0,1,3,2,1,2,1]来说，对于每个索引的左墙最高度为[0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]，右墙高度为[3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1]。 在找到两遍的墙的最大值之后，对于每个点，该点的左右墙的最小值即为水的高度。上述例子的最终水面高度就是[0, 1, 1, 2, 2, 2, 2, 3, 2, 2, 2, 1]，最后，减去原本的墙的高度，就可以得到结果。 123456789101112131415161718class Solution: def trap(self, height: 'list[int]') -&gt; 'int': maxHeight = [0] * len(height) tmpMax = 0 for i in range(len(maxHeight)): tmpMax = height[i] if height[i] &gt; tmpMax else tmpMax maxHeight[i] = tmpMax tmpMax = 0 for i in range(len(maxHeight)-1, -1, -1): tmpMax = height[i] if height[i] &gt; tmpMax else tmpMax maxHeight[i] = tmpMax if tmpMax &lt; maxHeight[i] else maxHeight[i] result = 0 for i in range(len(maxHeight)): result += (maxHeight[i] - height[i]) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode: 227. Basic Calculator II]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-227-Basic-Calculator-II%2F</url>
    <content type="text"><![CDATA[题目描述 Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero. Example 1: 12Input: &quot;3+2*2&quot;Output: 7 Example 2: 12Input: &quot; 3/2 &quot;Output: 1 Example 3: 12Input: &quot; 3+5 / 2 &quot;Output: 5 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. 与之前的Basic Calculator一样，难点在于如何处理运算的优先级。但是与之前的括号不同，*和/仅仅是一个二元运算符，所以这题不需要使用递归，而只需要一个栈就可以了。 首先需要对字符串进行处理和分割，大致步骤与Basic Calculator一致，得到经过处理后的数字和操作符组成的数组newList，比如” 3+5 / 2”经过处理后得到[‘3’, ‘+’, ‘5’, ‘/‘, ‘2’]。 初始的stack为newList[0]，接下来，我们需要从头到尾对数组进行遍历。当遍历到’+’，则直接push进下一个元素，当遍历到’-‘的时候，push进下一个元素的相反数，当遍历到’*’和’/‘的时候，需要pop出栈顶元素后，与下一个元素进行乘法或除法的操作后，将结果push进stack。最后，将stack的所有元素相加，得到最终结果。 纵观全过程，我们是在遍历到乘号或除号的时候直接对数字进行操作，而最后对stack的所有元素相加则为对加减法的统一操作。因此可以实现乘除法的优先级大于加减法的操作。 代码实现 1234567891011121314151617181920212223242526272829303132333435class Solution: def calculate(self, s: str) -&gt; int: s = s.replace(" ","") s = s.replace("+", " + ") s = s.replace("-", " - ") s = s.replace("*", " * ") s = s.replace("/", " / ") s = s.strip() sList = s.split(" ") filterList = filter(lambda x: x != "", sList) newList = list(filterList) stack = [int(newList[0])] i = 1 while i &lt; len(newList): if newList[i] == '+': i += 1 stack.append(int(newList[i])) elif newList[i] == '-': i += 1 stack.append(-int(newList[i])) elif newList[i] == '*': i += 1 last = stack.pop() stack.append(last * int(newList[i])) elif newList[i] == '/': i += 1 last = stack.pop() stack.append(int(last / int(newList[i]))) else: assert 0 i += 1 return sum(stack)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:226. Invert Binary Tree]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述 Invert a binary tree. Example: Input: 12345 4 / \ 2 7 / \ / \1 3 6 9 Output: 12345 4 / \ 7 2 / \ / \9 6 3 1 本题就是让我们反转一下二叉树，左右子树进行对调。可以使用一个递归实现。 123456789101112class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if root == None: return root tmp = root.left root.left = root.right root.right = tmp if root.left: self.invertTree(root.left) if root.right: self.invertTree(root.right) return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:225. Implement Stack using Queues]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[题目描述 Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue — which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 代码实现 12345678910111213141516171819202122232425262728293031class MyStack: def __init__(self): """ Initialize your data structure here. """ self.stack = [] def push(self, x: int) -&gt; None: """ Push element x onto stack. """ self.stack.append(x) def pop(self) -&gt; int: """ Removes the element on top of the stack and returns that element. """ return self.stack.pop() def top(self) -&gt; int: """ Get the top element. """ return self.stack[-1] def empty(self) -&gt; bool: """ Returns whether the stack is empty. """ return True if len(self.stack) == 0 else False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:10. Regular Expression Matching]]></title>
    <url>%2F2019%2F08%2F31%2FLeetCode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[题目描述 Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 决定每天复习一下没有写在博客里的旧题hhh 这一题是一道hard的字符串匹配，难点在于匹配’‘。这里的\代表任意个跟随着的字符，比如说A*可以匹配””, “A”, “AA”, “AAA”。 总体的算法以递归实现。可以想象s和p各自有一个从0开始的index，称为index1和index2，他们会对s和p进行从左到右的匹配，如果说两个索引都走到了各自字符串的头的时候，就说明匹配完成。 当p[index2+1]不为’*’时，s[index1] == p[index2]（或p[index2]为’.’）的时候，s和p在各自的index上匹配，index1和index2个字加1，进行下一次匹配 当p[index2+1]为’‘的时候，可以匹配s[index1] == p[index2]（或p[index2]为’.’），或者说匹配s[index1] == p[index2+2]（此时跳过匹配p[index2]，’\‘对应s中的空白字符） 当index1走到s的头的时候，我们需要确定index2是否走到头，如果index2走到了头，则匹配成功，如果没有走到头，则要确定p中index2开始的子字符串都是由一个普通字符和一个’*‘交替组成的，如”A*.*C*“，如果是这样的话也是匹配成功，反之失败。 当index2走到p的头的时候，直接判断index1是否走到头，如果走到了就匹配成功。 具体实现方面，并没有用到index1和index2，而是在调用的时候使用了诸如s[1:]来表示index1+1的操作，并且每次仅比较s和p的index为0的字符。这样可以简化写法。 代码实现 12345678910111213141516171819202122232425262728293031class Solution: def allStar(self, p): if len(p) % 2 == 1: return False for i in range(1, len(p), 2): if p[i] != '*': return False return True def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if len(p) == 0: if len(s) == 0: return True else: return False if len(s) == 0: return self.allStar(p) if len(p) &gt; 1 and p[1] == '*': return (p[0] in [s[0], '.'] and self.isMatch(s[1:], p)) or self.isMatch(s, p[2:]) elif s[0] == p[0] or p[0] == '.': return self.isMatch(s[1:], p[1:]) else: return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:224. Basic Calculator]]></title>
    <url>%2F2019%2F08%2F31%2FLeetCode-224-Basic-Calculator%2F</url>
    <content type="text"><![CDATA[题目描述 Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negativeintegers and empty spaces ``. Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. 这题需要实现一个简单的计算器，比较难的点在于如何处理括号。在对字符串进行处理后，根据’+’, ‘-‘, ‘(‘, ‘)’作为分隔符，得到每一个数字和他们对应的运算符号，存在一个list里。 每次遇到’(‘的时候，就需要进行一次递归，在遇到’)’的时候，从该层递归返回结果。 代码实现 12345678910111213141516171819202122232425262728293031323334class Solution: def calculate(self, s: str) -&gt; int: def tmpCalculation(index): tmp = 0 sign = 1 while index &lt; len(newList): if newList[index] == '(': returnResult, index = tmpCalculation(index + 1) tmp = tmp + sign * returnResult elif newList[index] == ')': return tmp, index elif newList[index] == '+': sign = 1 elif newList[index] == '-': sign = -1 else: tmp = tmp + sign * int(newList[index]) index += 1 return tmp, index s = s.replace(" ", "") s = s.replace("+", " + ") s = s.replace("-", " - ") s = s.replace("(", " ( ") s = s.replace(")", " ) ") s = s.strip() sList = s.split(" ") filterList = filter(lambda x: x != "", sList) newList = list(filterList) result, _ = tmpCalculation(0) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:223. Rectangle Area]]></title>
    <url>%2F2019%2F08%2F31%2FLeetCode-223-Rectangle-Area%2F</url>
    <content type="text"><![CDATA[题目描述 Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Example: 12Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int. 这题的核心就是求重叠部分的面积。 实际上，重叠部分的左下角为(max(A, E), max(B, F))，右上角为(min(C, G), min(D, H))，如果左下角的点不在右上角的点的左下方，则重叠面积为0。 代码实现 12345678910111213class Solution: def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -&gt; int: result = (C-A) * (D-B) + (G-E) * (H-F) rtx = min(C, G) rty = min(D, H) ldx = max(A, E) ldy = max(B, F) if ldx &gt; rtx or ldy &gt; rty: return result else: result -= (rtx - ldx) * (rty - ldy) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:222. Count Complete Tree Nodes]]></title>
    <url>%2F2019%2F08%2F29%2FLeetCode-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[题目描述 Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: 12345678Input: 1 / \ 2 3 / \ /4 5 6Output: 6 代码实现 12345678910111213141516class Solution: def countNodes(self, root: TreeNode) -&gt; int: result = 0 if root == None: return 0 nodes = [root] while len(nodes) &gt; 0: tmp = nodes.pop(0) result += 1 if tmp.left != None: nodes.append(tmp.left) if tmp.right != None: nodes.append(tmp.right) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:221. Maximal Square]]></title>
    <url>%2F2019%2F08%2F29%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[题目描述 Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 这题最快的方法还是使用动态规划。当matrix[i][j]为0时，dp[i][j]为0，当matrix[i][j]为1时，状态转移方程为： dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1 dp[i][j]表示从左上角到matrix[i][j]的最大的正方形的边长。在每一个matrix为1的点，需要看它左上方，上方和左边的dp值，取最小的+1，才是当前的dp。因为最小的边长才是制约dp[i][j]大小的因素。 代码实现 123456789101112131415161718192021222324252627282930class Solution: def maximalSquare(self, matrix: 'List[List[str]]') -&gt; 'int': n = len(matrix) if n == 0: return 0 m = len(matrix[0]) if m == 0: return 0 dp = [[0] * m for _ in range(n)] for i in range(n): if matrix[i][0] == "1": dp[i][0] = 1 for j in range(m): if matrix[0][j] == "1": dp[0][j] = 1 for i in range(1, n): for j in range(1, m): if matrix[i][j] == "1": dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1 result = 0 for i in range(0, n): for j in range(0, m): result = max(dp[i][j], result) return result**2]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:220. Contains Duplicate III]]></title>
    <url>%2F2019%2F08%2F29%2FLeetCode-220-Contains-Duplicate-III%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolutedifference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Example 1: 12Input: nums = [1,2,3,1], k = 3, t = 0Output: true Example 2: 12Input: nums = [1,0,1,1], k = 1, t = 2Output: true Example 3: 12Input: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false 这题时间复杂度为O(n)的方法比较巧妙，将nums里的所有数字除以t后向下取整得到modifiedNums，如果modifiedNums中有两个数字相同，那么它们一定会相差t以内，因此一定返回True，如果没有两个数字相同，那么就去查找比它小1或大1的数字，然后比较它们对应的原数字是否相差t以内。 但是这题要使用一个滑动窗口和一个字典来进行操作。滑动窗口来满足索引差值在k以内，字典的键为modifiedNums中的数字，值为nums中的数字，主要是为了查找到某个键是否在modifiedNums中（如果有直接返回True），以及方便查找原数字的值。字典操作的复杂度都为O(n)。 坑的点主要是t为0的时候，这个时候的情况和t为1的情况其实是一样的。 代码实现 12345678910111213141516171819202122232425class Solution: def containsNearbyAlmostDuplicate(self, nums: 'list[int]', k: 'int', t: 'int') -&gt; 'bool': if len(nums) &lt;= 1: return False if k &lt; 0 or t &lt; 0: return False modifiedNums = [i//max(1, t) for i in nums] leftIndex = 0 bucket = &#123;modifiedNums[0]: nums[0]&#125; for rightIndex in range(1, len(nums)): if rightIndex - leftIndex &gt; k: del bucket[modifiedNums[leftIndex]] leftIndex += 1 if modifiedNums[rightIndex] in bucket.keys(): return True if modifiedNums[rightIndex] - 1 in bucket.keys() and abs( bucket[modifiedNums[rightIndex] - 1] - nums[rightIndex]) &lt;= t: return True if modifiedNums[rightIndex] + 1 in bucket.keys() and abs( bucket[modifiedNums[rightIndex] + 1] - nums[rightIndex]) &lt;= t: return True bucket[modifiedNums[rightIndex]] = nums[rightIndex] return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:197. Rising Temperature]]></title>
    <url>%2F2019%2F08%2F29%2FLeetCode-197-Rising-Temperature%2F</url>
    <content type="text"><![CDATA[题目描述 Given a Weather table, write a SQL query to find all dates’ Ids with higher temperature compared to its previous (yesterday’s) dates. 12345678+---------+------------------+------------------+| Id(INT) | RecordDate(DATE) | Temperature(INT) |+---------+------------------+------------------+| 1 | 2015-01-01 | 10 || 2 | 2015-01-02 | 25 || 3 | 2015-01-03 | 20 || 4 | 2015-01-04 | 30 |+---------+------------------+------------------+ For example, return the following Ids for the above Weather table: 123456+----+| Id |+----+| 2 || 4 |+----+ 考查date_sub的用法，date_sub(date, interval k day)为找到date的前k天并返回。 date可用curdate()表示今天。 代码实现 12select s.id from weather as s, weather as twhere s.temperature &gt; t.temperature and t.recorddate = date_sub(s.recorddate, interval 1 day);]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:191. Number of 1 Bits]]></title>
    <url>%2F2019%2F08%2F29%2FLeetCode-191-Number-of-1-Bits%2F</url>
    <content type="text"><![CDATA[题目描述 Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight). Example 1: 123Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits. Example 2: 123Input: 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit. Example 3: 123Input: 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits. 代码实现 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int result = 0; while (n &gt; 0)&#123; if (n &amp; 1) &#123; result ++; &#125; n &gt;&gt;= 1; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:190. Reverse Bits]]></title>
    <url>%2F2019%2F08%2F28%2FLeetCode-190-Reverse-Bits%2F</url>
    <content type="text"><![CDATA[题目描述 Reverse bits of a given 32 bits unsigned integer. Example 1: 12Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000 Example 2: 12Input: 11111111111111111111111111111101Output: 10111111111111111111111111111111 考查位运算，比较坑的点是位运算符的优先级相对于四则运算更低。 代码实现 123456789101112131415class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t result = 0; for (int i = 0; i &lt; 32; i++) &#123; result &lt;&lt;= 1; if (n &amp; 1) &#123; result += 1; &#125; n &gt;&gt;= 1; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:189. Rotate Array]]></title>
    <url>%2F2019%2F08%2F28%2FLeetCode-189-Rotate-Array%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: 123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: 12345Input: [-1,-100,3,99] and k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] 利用另一个数组对结果进行存储。 代码实现 12345678910111213class Solution: def rotate(self, nums: 'list[int]', k: 'int') -&gt; None: """ Do not return anything, modify nums in-place instead. """ n = len(nums) tmp = n * [0] for i in range(len(nums)): tmp[(i+k)%n] = nums[i] for i in range(len(nums)): nums[i] = tmp[i]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:188. Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[题目描述 Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: 123Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: 1234Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 这题可以看成两部分，当k很大的时候，和Best Time to Buy and Sell Stock II一样，可以看成无限次买卖。只要找到数组中的所有递增的子序列，并且求每个子序列两端的差值之和。 当k很小的时候，使用Best Time to Buy and Sell Stock III的DP算法。构建两个数组localMax和globalMax，其中localMax[i][j]表示在第i天交易了j次，并且最后一天将股票卖出的最大值，而globalMax[i][j]则是第i天交易了j次的最大值。状态转移方程为： localMax[i][j] = max(localMax[i-1][j]+price[i]-price[i-1], globalMax[i-1][j-1]+max(0, price[i]-price[i-1])) globalMax[i][j] = max(globalMax[i][j-1], local[i][j]) 对于全局最优globalMax来说，在最后一天的买卖情况可以分为卖和不卖，如果不卖，那么globalMax[i][j] = globalMax[i][j-1]，因此我们需要用另一个状态转移方程来表示最后一天卖的情况，也就是localMax。 对于localMax来说，如果最后一天可以有三种情况得到。第一种是在对于localMax[i-1][j]来说的最后一次买卖到第i天执行，也就是localMax[i-1][j]+price[i]-price[i-1]；第二种可能是在i-1天交易j-1次时，对于全局最优globalMax[i-1][j-1]来说，在倒数第二天和倒数第一天执行一次交易；最后一种情况则是在i-1天交易j-1次时，对于全局最优globalMax[i-1][j-1]来说在最后一天买了又卖（得到0元），其中最后两种可以合并，即globalMax[i-1][j-1]+max(0, price[i]-price[i-1])。这些情况的最大值就是localMax的新的状态。 代码实现 123456789101112131415161718192021222324252627282930class Solution: def maxProfit(self, k: 'int', prices: 'list[int]') -&gt; 'int': def smallK(): if len(prices) == 0 or k == 0: return 0 times = min(k, len(prices)) + 1 localMax = [times * [0] for _ in range(len(prices))] globalMax = [times * [0] for _ in range(len(prices))] for i in range(1, len(prices)): for j in range(1, times): localMax[i][j] = max(localMax[i - 1][j] + prices[i] - prices[i - 1], globalMax[i - 1][j - 1] + max(prices[i] - prices[i - 1], 0)) globalMax[i][j] = max(globalMax[i - 1][j], localMax[i][j]) return globalMax[-1][-1] def largeK(): result = 0 tmp = 0 for i in range(1, len(prices)): if prices[i] &lt; prices[i-1]: result += tmp tmp = 0 else: tmp += prices[i] - prices[i-1] return result if k &lt; len(prices): return smallK() else: return largeK()]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:187. Repeated DNA Sequences]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-187-Repeated-DNA-Sequences%2F</url>
    <content type="text"><![CDATA[题目描述 All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: 123Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 创建两个set，第一个set用来存放结果，另一个set用来存放从头到尾遍历的字符长度为10的子字符串的结果。如果遍历到的字符串再第二个set中存在，就把它存放到第一个结果set中，否则就将它放到第二个set中。由于使用set，复杂度为O(n)，n为s的长度 代码实现 12345678910class Solution: def findRepeatedDnaSequences(self, s: 'str') -&gt; 'List[str]': nums = set() result = set() for i in range(len(s)-9): if s[i:i+10] in nums: result.add(s[i:i+10]) else: nums.add(s[i:i+10]) return list(result)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:184. Department Highest Salary]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-184-Department-Highest-Salary%2F</url>
    <content type="text"><![CDATA[题目描述 The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. 123456789+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Jim | 90000 | 1 || 3 | Henry | 80000 | 2 || 4 | Sam | 60000 | 2 || 5 | Max | 90000 | 1 |+----+-------+--------+--------------+ The Department table holds all departments of the company. 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter). 1234567+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || IT | Jim | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department. 首先需要把两张表根据departmentid join起来，接着需要在employee表中找到每个department中salary的最高值，并且记录其对应的departmentid，最后在join起来的最终结果中寻找每个(departmentid, 最高的salary)所对应的组。 代码实现 123456789select department.name as Department, employee.name as Employee, Salaryfrom employeejoin departmenton employee.departmentid = department.idwhere (employee.departmentid, Salary) in ( select departmentid, max(salary) from employee group by departmentid);]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:183. Customers Who Never Order]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-183-Customers-Who-Never-Order%2F</url>
    <content type="text"><![CDATA[题目描述 Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Table: Orders. 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ Using the above tables as example, return the following: 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ 这题考查的是sql中in的用法，找到customers中不在orders的那些id就可以了 123select name as Customersfrom customerswhere id not in (select customerid from orders);]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:182. Duplicate Emails]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-182-Duplicate-Emails%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to find all duplicate emails in a table named Person. 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ For example, your query should return the following for the above table: 12345+---------+| Email |+---------+| a@b.com |+---------+ 这题考查having语句的用法 代码实现 1234select email from person group by emailhaving count(email) &gt; 1;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:181. Employees Earning More Than Their Managers]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-181-Employees-Earning-More-Than-Their-Managers%2F</url>
    <content type="text"><![CDATA[题目描述 The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. 12345+----------+| Employee |+----------+| Joe |+----------+ 在where语句中查找出每行对应的manager的salary后进行比较即可。 代码实现 123select s.name as Employeefrom Employee as swhere s.Salary &gt; (select t.Salary from Employee as t where t.id = s.managerid)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:179. Largest Number]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-179-Largest-Number%2F</url>
    <content type="text"><![CDATA[题目描述 Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; 题目要求对一串数组进行重新排列，让他们组合成最大的数字。比如[10,2]排列成”210”，[3,30,34,5,9]排列成”9534330”。 我们需要对每个字符的位数依次比较，比如[3,30,34,5,9]，第一位最大的是9，那么9就一定排在第一个，第一位第二大的是5，那么5就排在第二个，第三大的是3，然后就比第二位，于是第三个数字就是34…事实上，对于字符串a和b来说，如果a+b大于b+a，那么在最终排列的时候，a一定排在b的前面。 因此只需要实现一个compare函数，利用python内置的sort进行快排，就可以很快地得到我们需要的排序结果。最后注意要删除最左边的”0”，以及确保字符串不为空 代码实现 12345678910111213141516171819202122from functools import cmp_to_keyclass Solution: def largestNumber(self, nums: List[int]) -&gt; str: def compare(x, y): if int(str(x)+str(y)) &gt; int(str(y)+str(x)): return 1 elif int(str(x)+str(y)) &lt; int(str(y)+str(x)): return -1 else: return 0 nums = sorted(nums, key=cmp_to_key(compare)) result = "" for i in range(len(nums)-1, -1, -1): result += str(nums[i]) result = result.lstrip("0") result = "0" if result == "" else result return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:178. Rank Scores]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-178-Rank-Scores%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks. 12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ For example, given the above Scores table, your query should generate the following report (order by highest score): 12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ 这题的思路就是构建一张空的表格t，该表格中的score分数由原表格s生成，但是score唯一。 然后比较两张表格。对于每个s中的分数，需要统计t中比s的score更大或相等的数字有几个。 这里要注意的就是需要加上group by s.id的语句，这里的group by的功能大概就是为了在输出的时候，确定每个id都输出的意思。不加group by则只会输出一行。 代码实现 1234567select s.Score, count(t.Score) as Rankfrom Scores as s,(select distinct Score from Scores) as t where s.Score &lt;= t.scoregroup by s.idorder by s.Score desc;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:177. Nth Highest Salary]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-177-Nth-Highest-Salary%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to get the nth highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. 12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ 这里需要使用函数实现查询第N大的salary，考察的是对limit的使用。 limit n, m表示除去前n项后，再输出m项，因此在这里需要limit N-1, 1就可以满足要求。但是由于limit语句中不能做算术操作，因此要将N-1赋值给另外一个变量后M后，再使用limit M, 1。 赋值的时候注意SQL是大小写不敏感的。 代码实现 123456789CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINdeclare M int;set M = N-1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary desc limit M, 1 );END]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:176. Second Highest Salary]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-176-Second-Highest-Salary%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to get the second highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 查找第二大的元素，只需要在where语句中过滤掉最大的元素后再使用max即可 代码实现 1select max(Salary) as SecondHighestSalary from Employee where Salary &lt; (select max(Salary) from Employee)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:219. Contains Duplicate II]]></title>
    <url>%2F2019%2F07%2F03%2FLeetCode-219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: 12Input: nums = [1,2,3,1], k = 3Output: true Example 2: 12Input: nums = [1,0,1,1], k = 1Output: true Example 3: 12Input: nums = [1,2,3,1,2,3], k = 2Output: false 这题需要找数组中存在nums[i] == nums[j]，并且i和j的差的绝对值小于等于k。 这里需要用一个字典进行存储，字典的键为nums[i]，值为i。从左到右遍历数组nums，如果nums[i]没有出现在字典的键中，则添加nums[i]到字典里。如果字典中已经有nums[i]，则将比较i与该键所对应的值的差值，如果小于k则返回True，否则更新该值。 代码实现 123456789101112class Solution: def containsNearbyDuplicate(self, nums: 'list[int]', k: 'int') -&gt; 'bool': M = &#123;&#125; for i in range(len(nums)): if nums[i] not in M.keys(): M[nums[i]] = i else: if i - M[nums[i]] &lt;= k: return True else: M[nums[i]] = i return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:218. The Skyline Problem]]></title>
    <url>%2F2019%2F07%2F02%2FLeetCode-218-The-Skyline-Problem%2F</url>
    <content type="text"><![CDATA[题目描述 A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Riare the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]. The output is a list of “key points“ (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ]that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] 题目需要让我们求出几个长方形组成的轮廓，返回的点唯一确定这个轮廓。从B图中可以发现，所有返回的点实际上为轮廓高度的突变点。而所有可能的突变点，均为长方形竖着的边。为了做区分，我把左边的边称为开始边，右边的边称为结束边。 因此，我们需要从左向右遍历矩形的开始边盒结束边，并且记录当前的最高点的高度。所以我们需要维护一个有序的list，当遍历到的边为开始边时，把开始边的高度增加到这个有序列表中，如果是结束边，则把该边的高度从列表中删除。 在实际操作的时候，我们需要把[Li, Ri, Hi]分解为[Li, -Hi]和[Ri, Hi]，然后统一存放到同一个数组中，并且根据Li和Ri的值进行无差别的排列。这样可以方便之后从左向右进行遍历，并且在遍历的同时能区分开始边和结束边。 在网上的一些方法中，有人使用了MaxHeap，这个堆可以很快地返回最大值，并且可以很方便地进行删除和增加操作，时间复杂度为O(n)。但是Python中需要对其进行额外实现，然而直接使用快速排序维持一个有序列表的方法也能通过OJ，所以在这里我就只是用了快速排序。 代码实现 123456789101112131415161718192021222324252627282930313233343536import functoolsclass Solution: def getSkyline(self, buildings: 'list[list[int]]') -&gt; 'list[list[int]]': def cmp(x, y): if x[0] != y[0]: return x[0] - y[0] else: return x[1] - y[1] nodes = [] result = [] if len(buildings) == 0: return result for i in buildings: nodes.append([i[0], -i[2]]) nodes.append([i[1], i[2]]) nodes = sorted(nodes, key=functools.cmp_to_key(cmp)) peak = 0 peaks = [0] for i in nodes: if i[1] &lt; 0: peaks.append(-i[1]) peaks = sorted(peaks) else: peaks.remove(i[1]) current = peaks[-1] if current != peak: result.append([i[0], current]) peak = current return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:216. Combination Sum III]]></title>
    <url>%2F2019%2F07%2F01%2FLeetCode-216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[题目描述 Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12Input: k = 3, n = 7Output: [[1,2,4]] Example 2: 12Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] 使用DFS查找可以很快找到所有的组合。 代码实现 1234567891011121314151617181920212223import copyclass Solution: def combinationSum3(self, k: int, n: int) -&gt; 'list[list[int]]': def dfs(current, sum): if len(current) == k and sum == n: result.append(copy.deepcopy(current)) return if sum &gt;= n or len(current) &gt;= k: return start = 1 if len(current) == 0 else current[-1] + 1 for i in range(start, 10, 1): sum += i current.append(i) dfs(current, sum) sum -= i current.pop() result = [] dfs([], 0) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:214. Shortest Palindrome]]></title>
    <url>%2F2019%2F06%2F29%2FLeetCode-214-Shortest-Palindrome%2F</url>
    <content type="text"><![CDATA[题目描述 Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: 12Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot; Example 2: 12Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot; 给定一个字符串，我们需要在字符串的开头添加若干字符串，使新的字符串成为回文的字符串。比如“abcd”变成“dcbabcd”；“aacecaaa”变成“aaacecaaa” 如果一个字符串A可以表示为BS，其中B和S非空，那么B就是A的在该字符串中的前缀，S为字符串的后缀。这一题的核心就是去求该字符串回文前缀有多长，比如“aacecaaa”的回文前缀最长为“aacecaa”，我们就只需要再补一个“a”，与最后一个字符“a”对应就可以了。 如果对长度为n的字符串从第0个位置到第n/2个位置分别判断是否为回文字符串，那么其时间复杂度是n^2。 但是这里我们会使用KMP算法中的next数组。next数组存储了每一个索引之前的子字符串的前缀与后缀相同的最大值。 对于字符串abababca来说，当index = 5时，其之前的字符串为”ababa”，”ababa”的前缀为[“a”, “ab”, “aba”, “abab”]，后缀是[“a”, “ba”, “aba”, “baba”]，前缀和后缀中最长的相同字符串为”aba”，因此这里的next[5]就是3。 对于本题，我们的方法是将原字符串的逆序添加到原字符串的后面，因为我们要找的是字符串的前序回文字符串的最大值，那么这个回文字符串的逆序会在新生成的字符串的最后，并且与开头的这个回文字符串相同，因此本题就转化成了求解这个新生成的字符串的next。 举个例子，对于”aacecaaa”来说，我们会在它之后加一个特殊字符作为切分，然后添加它的逆字符串，生成”aacecaaa#aaacecaa”，并且在最后再加上一位，让next[-1]能表示新增一位的前面的所有字符。最终生成的字符串为”aacecaaa#aaacecaa*”。对于next[-1]来说，其对应的子字符串为”aacecaaa#aaacecaa”的前缀和后缀相同的字符串的长度，也就是“aacecaa”，长度为7，这样就找到了原字符串的最长回文前缀了。 KMP算法的next数组可以帮助我们很快找到字符串的前缀和后缀的相同字符串。next的求法如下所示： 123456789101112131415def getNext(self, p): next = [0] * len(p) next[0] = -1 i = 0 j = next[0] while i &lt; len(p)-1: if j == -1 or p[i] == p[j]: i += 1 j += 1 next[i] = j else: j = next[j] return next 其核心思想就是维护两个索引，其中i为next的下一个需要求的索引，j为最长的回文前缀的索引。由于next保存了i之前的前缀和后缀的最大相同值，因此让j=next[i]，可以保证其i+1的最长相同值不大于j。 代码实现 123456789101112131415161718192021222324252627282930313233class Solution: def shortestPalindrome(self, s: str) -&gt; str: newS = s + '#' for i in range(len(s)-1, -1, -1): newS += s[i] newS += "*" next = self.getNext(newS) index = next[-1] result = "" for i in range(len(s)-1, index-1, -1): result += s[i] result += s return result def getNext(self, p): next = [0] * len(p) next[0] = -1 i = 0 j = next[0] while i &lt; len(p)-1: if j == -1 or p[i] == p[j]: i += 1 j += 1 next[i] = j else: j = next[j] return next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:213. House Robber II]]></title>
    <url>%2F2019%2F06%2F27%2FLeetCode-213-House-Robber-II%2F</url>
    <content type="text"><![CDATA[题目描述 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. 本题是之前House Robber的升级版。在这里，所有的房子形成一个环形，言下之意就是第一个房子和最后一个房子不能都偷。 假设有n个房子，他们的财产为house[0], house[1], …, house[n-1]，要保证house[0]和house[n-1]都不被偷，并且求出能偷的最大值。如果不偷house[n-1]，那么就转化成了House Robber中的house[0], …, house[n-2]的情形；同理，如果不偷house[0]，那么就转化成了求house[1], …, house[n-1]的情形。因此，本题就是求House Robber中的house[0], …, house[n-2]和house[1], …, house[n-1]的最大值。 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution: def rob1(self, nums) -&gt; 'list[int]': if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp def rob2(self, nums) -&gt; 'list[int]': if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[len(nums)-1] = nums[len(nums)-1] dp[len(nums)-2] = max(nums[len(nums)-1], nums[len(nums)-2]) for i in range(len(nums)-3, -1, -1): dp[i] = max(dp[i+1], dp[i+2] + nums[i]) return dp def rob(self, nums: 'list[int]') -&gt; 'int': if len(nums) &lt;= 2: return max(nums) dp1 = self.rob1(nums) dp2 = self.rob2(nums) return max(dp1[-2], dp2[1])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:212. Word Search II]]></title>
    <url>%2F2019%2F06%2F26%2FLeetCode-212-Word-Search-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: 12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] Note: All inputs are consist of lowercase letters a-z. The values of words are distinct. 这题我一开始尝试暴力搜索，需要对所有字符串，board的长和宽都进行一次循环遍历。最后出了很多bug，而且超时。 后来查阅了网上的一些资料，才知道这题也要使用之前的Trie树来进行搜索。这样可以减少一层的循环。 所以一开始，需要把word里的所有字符串存到Trie中，然后对board中的所有元素依此进行深度优先搜索，查找当前的字符是否在Trie当前节点的子节点中，如果没有则直接返回，如果有，则让当前Trie的节点变为该子节点，然后查找当前字符的上下左右四个相邻的字符是否在新的Trie节点的子节点中，以此类推，实现一个深度优先搜索。如果当前节点是某个Trie中的字符串的结束字符，则将该字符串存入结果中，最终返回结果。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node: def __init__(self, val): self.val = val self.next = [None] * 26 self.end = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.start = Node("") def insert(self, word: str) -&gt; None: """ Adds a word into the data structure. """ this = self.start for i in range(len(word)): index = ord(word[i]) - ord('a') if this.next[index] == None: this.next[index] = Node(this.val + word[i]) this = this.next[index] this.end = Trueclass Solution: def findWords(self, board: 'list[list[str]]', words: 'list[str]') -&gt; 'list[str]': def dfs(root, x, y): if isVisited[x][y] == 1: return if root.end == True: result.append(root.val) root.end = False isVisited[x][y] = 1 direct = [[0, 1], [1, 0], [0, -1], [-1, 0]] for dir in direct: newx = x + dir[0] newy = y + dir[1] if newx &lt; 0 or newx &gt;= len(board) or newy &lt; 0 or newy &gt;= len(board[0]): continue if root.next[ord(board[newx][newy]) - ord('a')] != None: dfs(root.next[ord(board[newx][newy]) - ord('a')], newx, newy) isVisited[x][y] = 0 trie = Trie() for word in words: trie.insert(word) result = [] if len(board) == 0 or len(board[0]) == 0: return result isVisited = [[0] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if trie.start.next[ord(board[i][j]) - ord('a')] != None: dfs(trie.start.next[ord(board[i][j]) - ord('a')], i, j) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:211. Add and Search Word - Data structure design]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-211-Add-and-Search-Word-Data-structure-design%2F</url>
    <content type="text"><![CDATA[题目描述 Design a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 本题就是要实现一个数据结构，可以进行增加字符串和查找功能，这里的查找功能可以是模糊查找。 本题的数据结构与之前的Trie一致，但是查找方面不同。这里的查找使用DFS，如果出现要匹配’.’，则需要在所有的子树上进行查找，任意子树返回True，则为匹配成功。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node: def __init__(self, val): self.val = val self.next = [] self.end = Falseclass WordDictionary: def __init__(self): """ Initialize your data structure here. """ self.start = Node(-1) def addWord(self, word: str) -&gt; None: """ Adds a word into the data structure. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: newNode = Node(word[index]) this.next.append(newNode) this = newNode index += 1 this.end = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. """ return self.dfs(word, self.start, 0) def dfs(self, word, node, index): if index == len(word): return node.end if word[index] == '.': for i in node.next: if self.dfs(word, i, index+1): return True return False else: for i in node.next: if i.val == word[index] and self.dfs(word, i, index+1): return True return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:209. Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-209-Minimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example: 123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 题目要求在一串数字中找到最短的连续数字，让他们的和大于给定的正数。 这里需要记录数组的开始和结尾的索引，并且需要记录连续的数字之和。每当数字比给定目标小的时候，右边的索引要往右移动，其他情况则左边索引向右移动一格，并且如果比最小的结果更小的时候需要记录这个长度。 代码实现 123456789101112131415161718192021222324252627class Solution: def minSubArrayLen(self, s: int, nums: 'list[int]') -&gt; int: if len(nums) == 0: return 0 start = 0 end = 1 sum = nums[0] result = len(nums) find = False while True: if sum &gt;= s: find = True result = end - start if end - start &lt; result else result if start &lt; len(nums)-1: sum -= nums[start] start += 1 else: break else: if end &lt; len(nums): sum += nums[end] end += 1 else: break return 0 if find == False else result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:208. Implement Trie (Prefix Tree)]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-208-Implement-Trie-Prefix-Tree%2F</url>
    <content type="text"><![CDATA[题目描述 Implement a trie with insert, search, and startsWith methods. Example: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Trie树能够存储字符串，它的每一个节点都代表了一个字母，结构如下所示： 上图中，存放了at、bee、ben、bt、q五个字符串。其中绿色代表着字符串的结束，它可以出现在树的非叶子节点。 因此对于每个节点，需要存放其值，子节点以及是否位字符串的结束，其定义如下： 12345class Node: def __init__(self, val): self.val = val self.next = [] self.end = False 在进行insert(‘bed’)的时候，会从最顶的节点开始向下查找，如果查找到’b’，那么就会在这个’b’节点继续往下查找’e’，如果也有的话继续在’e’查找’d’ 。但是如果一开始没有查找到’b’，则会新创建一个节点’b’，然后在这个新节点下面继续查找’e’（虽然一定是找不到的），找不到的话创建’e’ ，以此类推。 在进行search的时候，也会从头节点开始向下进行查找，但是如果找不到，那么会直接返回False。如果完整地找到了这个字符串，还需要看该字符串的最后一个节点的end是否为True，如果是则返回True，否则返回False。 startswith操作和search操作基本一致，但是它不需要检查字符串的最后一个节点的end状态。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Node: def __init__(self, val): self.val = val self.next = [] self.end = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.start = Node(-1) def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: newNode = Node(word[index]) this.next.append(newNode) this = newNode index += 1 this.end = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: return False if this.end == True: return True else: return False def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ this = self.start index = 0 while index &lt; len(prefix): find = False for i in this.next: if i.val == prefix[index]: find = True this = i index += 1 break if find == False: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:206. Reverse Linked List]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述 Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 用一个虚的头节点（如下的start节点）可以简化代码。 代码实现 12345678910111213141516class Solution: def reverseList(self, head: 'ListNode') -&gt; 'ListNode': if head == None: return head start = ListNode(0) start.next = head tmp = head last = start while tmp != None: nextTmp = tmp.next tmp.next = last last = tmp tmp = nextTmp head.next = None return last]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:205. Isomorphic Strings]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[题目描述 Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 12Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: true Example 2: 12Input: s = &quot;foo&quot;, t = &quot;bar&quot;Output: false Example 3: 12Input: s = &quot;paper&quot;, t = &quot;title&quot;Output: true 用了一个字符串，按顺序存放s和t的索引上的字母首次出现的位置，最后比较这两个位置是否相同。 代码实现 12345678910111213141516171819202122232425class Solution: def isIsomorphic(self, s: 'str', t: 'str') -&gt; 'bool': mapS = &#123;&#125; mapT = &#123;&#125; indexS = "" indexT = "" for i in range(len(s)): if s[i] not in mapS.keys(): mapS[s[i]] = i indexS += str(i) else: indexS += str(mapS[s[i]]) for i in range(len(t)): if t[i] not in mapT.keys(): mapT[t[i]] = i indexT += str(i) else: indexT += str(mapT[t[i]]) if indexS == indexT: return True else: return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:204. Count Primes]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-204-Count-Primes%2F</url>
    <content type="text"><![CDATA[题目描述 Count the number of prime numbers less than a non-negative number, n. Example: 123Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. 以n为121为例。本题的思想就是用数组的方法，先找2的倍数，把所有2的倍数（不包括2）进行标记。然后找接下来一个最小的没有被标记的数（3），将其倍数（不包括3）也标记起来。依此类推，一直做到11（根号121）为止。这是因为任何小于121的合数，必然会有一个因数小于11。 最后，数出没有被标记的数字的个数，就是小于121的质数的个数。 代码实现 12345678910111213141516171819class Solution: def countPrimes(self, n: 'int') -&gt; 'int': if n &lt; 3: return 0 isCount = [0] * n count = 0 for i in range(2, int(math.sqrt(n-1))+1): if isCount[i] == 0: index = i while index+i &lt; n: index += i isCount[index] = 1 for i in range(2, n): if isCount[i] == 0: count += 1 return count]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:203. Remove Linked List Elements]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[题目描述 Remove all elements from a linked list of integers that have value val. Example: 12Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 代码实现 123456789101112131415class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: start = ListNode(0) start.next = head tmp = head last = start while tmp != None: if tmp.val == val: last.next = tmp.next tmp = tmp.next else: last = last.next tmp = tmp.next return start.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:202. Happy Number]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-202-Happy-Number%2F</url>
    <content type="text"><![CDATA[题目描述 Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 1234567Input: 19Output: trueExplanation: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 快乐数就是将自己的每一位数字的平方加起来后，最终为1的数字，如果中间出现了循环，则它不是快乐数。 所以需要用一个list存放所有在计算中出现的数字，如果原数字在进行计算的时候，出现了list中的数字，则不是快乐数。 代码实现 12345678910111213141516171819class Solution: def isHappy(self, n: 'int') -&gt; 'bool': if n &lt;= 0: return False ns = [] while n is not 1: next_n = 0 if n in ns: return False ns.append(n) while n &gt; 0: next_n += (n % 10)**2 n = n // 10 n = next_n return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:201. Bitwise AND of Numbers Range]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-201-Bitwise-AND-of-Numbers-Range%2F</url>
    <content type="text"><![CDATA[题目描述 Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: 12Input: [5,7]Output: 4 Example 2: 12Input: [0,1]Output: 0 这道题目需要找到连续范围内的所有数的与，如果直接进行与的话会导致超时。 当m和n位数不同的时候，比如说m是0b11, n是0b111，由于由于他们位数不同，那么他们中一定会出现一个0b100，与m在后两位上的与都是0，所以m和n在位数不同的情况下一定是0. 当位数相同的时候，比如说m为0b11001，n为0b11100的时候，他们之间有0b11010，0b11011，可以看出，他们这些数字的头两位都是一样的，而后几位的与都为0. 因此，本题也就是要求解m和n的二进制表达下的头几位是相同的。考虑到之前的m和n位数不同的时候，m的头几位可以用0来补足，因此之前的特殊情况也符合该描述。 代码实现 1234567891011121314151617class Solution: def rangeBitwiseAnd(self, m: 'int', n: 'int') -&gt; 'int': tmp = n bits = 0 if m == n: return m while tmp &gt; 0: tmp = tmp &gt;&gt; 1 bits = bits*2 + 1 count = 1 while bits &amp; n != bits &amp; m: bits = bits &gt;&gt; count bits = bits &lt;&lt; count count += 1 return bits &amp; m]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:200. Number of Islands]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[题目描述 Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 1234567Input:11110110101100000000Output: 1 Example 2: 1234567Input:11000110000010000011Output: 3 这题需要一个额外的二维数组，来记录某一个点是否被检查过。然后我们需要对所有的点按顺序进行一次深度优先搜索，如果说这个点已经被检查过，则不再搜索。那么，一开始需要进行搜索的点的个数，就是岛屿的数量。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def __init__(self): self.count = 0 self.matrix = None def numIslands(self, grid: 'list[list[str]]') -&gt; 'int': if len(grid) == 0: return 0 if len(grid[0]) == 0: return 0 self.matrix = [[0] * len(grid[0]) for _ in range(len(grid))] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1' and self.matrix[i][j] == 0: self.count += 1 self.dfs(i, j, grid) return self.count def dfs(self, x, y, grid): if grid[x][y] == '1': self.matrix[x][y] = 1 if x &gt; 0 and self.matrix[x-1][y] == 0: self.dfs(x-1, y, grid) if y &gt; 0 and self.matrix[x][y-1] == 0: self.dfs(x, y-1, grid) if x &lt; len(grid)-1 and self.matrix[x+1][y] == 0: self.dfs(x+1, y, grid) if y &lt; len(grid[0])-1 and self.matrix[x][y+1] == 0: self.dfs(x, y+1, grid)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:199. Binary Tree Right Side View]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目描述 Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 这题很像之前的按照行来对树进行遍历，就是用一个类似先用一个queue来存放头节点，对queue中的所有元素的left和right进行检查，如果不是None的话就存放到另一个tmp_queue中，直到遍历完queue中的所有元素为止。接着把tmp_queue赋值给queue，进行新的一层的遍历。 所以只需要记录每一次的tmp_queue的最后一个元素即可。 代码实现 1234567891011121314151617181920class Solution: def rightSideView(self, root: 'TreeNode') -&gt; 'list[int]': result = [] if root == None: return result queue = [root] result.append(root.val) while len(queue) &gt; 0: tmp = [] for i in queue: if i.left != None: tmp.append(i.left) if i.right != None: tmp.append(i.right) if len(tmp) &gt; 0: result.append(tmp[-1].val) queue = tmp return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:198. House Robber]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[题目描述 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: 1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 这题就是一个很明显的动态规划。由于两次偷盗的索引不能相邻，因此某个索引的偷盗最大值为上个索引的偷盗最大值或上上个索引的偷盗值加上当前nums的值，即dp[i] = max(dp[i-1], dp[i-2] + nums[i]) 代码实现 1234567891011121314class Solution: def rob(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 dp = [0] * len(nums) dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(dp)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:174. Dungeon Game]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-174-Dungeon-Game%2F</url>
    <content type="text"><![CDATA[题目概述 The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3 -5 -10 1 10 30 -5 (P) Note: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 这道题目翻译一下，就是要保证这个骑士在走过每一个格子之后，血量至少为1。这题可以用动态规划来进行求解。如果一个格子上的数字为-5，那么骑士在踏上这个格子的时候，至少需要max(1, 1-(-5)) = 6点血量；如果格子上的数字为5，那么骑士只需要max(1, 1-5) = 1点血量。 接着需要考虑周围格子的情况。如果某个格子的右边的格子至少需要有4点血量，另一个格子至少要3点血量，那么在经过这个格子之后，我们需要至少保留min(4, 3) = 3点血量。 那么，状态转移公式就是dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) 代码实现 12345678910111213141516171819class Solution: def calculateMinimumHP(self, dungeon: 'list[list[int]]') -&gt; 'int': row = len(dungeon) column = len(dungeon[0]) dp = [[0] * column for _ in range(row)] dp[row-1][column-1] = max(1 - dungeon[row-1][column-1], 1) for i in range(column-2, -1, -1): dp[row-1][i] = max(dp[row-1][i+1] - dungeon[row-1][i], 1) for i in range(row - 2, -1, -1): dp[i][column - 1] = max(dp[i + 1][column - 1] - dungeon[i][column - 1], 1) for i in range(row - 2, -1, -1): for j in range(column - 2, -1, -1): dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) return dp[0][0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:173. Binary Search Tree Iterator]]></title>
    <url>%2F2019%2F06%2F17%2FLeetCode-173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[题目概述 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: 12345678910BSTIterator iterator = new BSTIterator(root);iterator.next(); // return 3iterator.next(); // return 7iterator.hasNext(); // return trueiterator.next(); // return 9iterator.hasNext(); // return trueiterator.next(); // return 15iterator.hasNext(); // return trueiterator.next(); // return 20iterator.hasNext(); // return false Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. 这题我使用了一个DFS来遍历BST，并且把按顺序把树的节点存到了self.nodes的list中。这个类同时还保存了一个当前对象在self.nodes的索引值，如果使用了next方法，就把这个索引值加一，hasnext则判断这个索引值和self.nodes的长度的关系 代码实现 12345678910111213141516171819202122232425262728class BSTIterator: def __init__(self, root: TreeNode): self.nodes = [] self.dfs(root) self.index = -1 def next(self) -&gt; int: """ @return the next smallest number """ self.index += 1 return self.nodes[self.index].val def hasNext(self) -&gt; bool: """ @return whether we have a next smallest number """ if self.index &lt; len(self.nodes) - 1: return True else: return False def dfs(self, root): if root == None: return self.dfs(root.left) self.nodes.append(root) self.dfs(root.right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:172. Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer n, return the number of trailing zeroes in n!. Example 1: 123Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: 123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. 在阶乘中，只有5的倍数能产生0，因此这道题就转化成了n!的因子中有多少个5. 这里需要注意的是，25，125这种数字包含了多个5，需要进行重复计算。 代码实现 12345678class Solution: def trailingZeroes(self, n: int) -&gt; int: divisor = 5 result = 0 while divisor &lt;= n: result += n // divisor divisor *= 5 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:171. Excel Sheet Column Number]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-171-Excel-Sheet-Column-Number%2F</url>
    <content type="text"><![CDATA[题目概述 Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... Example 1: 12Input: &quot;A&quot;Output: 1 Example 2: 12Input: &quot;AB&quot;Output: 28 Example 3: 12Input: &quot;ZY&quot;Output: 701 进制转换的题目 代码实现 12345678class Solution: def titleToNumber(self, s: 'str') -&gt; 'int': result = 0 for i in range(len(s)): result *= 26 result += ord(s[i]) - 64 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:169. Majority Element]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-169-Majority-Element%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 12Input: [3,2,3]Output: 3 Example 2: 12Input: [2,2,1,1,1,2,2]Output: 2 题目要求找到数组中的众数。我是把数组进行排序后从左到右找，如果当前数字和之前的数字一样，就会给一个记录值加一，如果发现当前数字与其之前的数字不一样，则把记录值和全局最大值进行比较。 代码实现 123456789101112131415161718192021class Solution: def majorityElement(self, nums: 'list[int]') -&gt; 'int': nums = sorted(nums) if len(nums) == 1: return nums[0] maxNum = 1 tmpNum = 1 targetIndex = 0 for i in range(1, len(nums)): if nums[i] == nums[i-1]: tmpNum += 1 elif i &lt; len(nums): if tmpNum &gt;= maxNum: targetIndex = i-1 maxNum = tmpNum tmpNum = 1 if i == len(nums)-1 and tmpNum &gt;= maxNum: targetIndex = i return nums[targetIndex]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:168. Excel Sheet Column Title]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-168-Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[题目概述 Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... Example 1: 12Input: 1Output: &quot;A&quot; Example 2: 12Input: 28Output: &quot;AB&quot; Example 3: 12Input: 701Output: &quot;ZY&quot; 进制转换的题目 代码实现 1234567891011class Solution: def convertToTitle(self, n: 'int') -&gt; 'str': result = "" while True: remainder = (n-1) % 26 n = int((n-1)/26) result = chr(65+remainder) + result if n == 0: break return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 简单题，由于数组是递增的，所以一开始假定index1为0，index2为数组的最后一个索引，如果对应的两个数相加比target小，则让index1加一，反之让index2减1，直到找到两个和为target的值的索引 最后注意把求得的index+1即可。 代码实现 123456789101112class Solution: def twoSum(self, numbers: 'list[int]', target: 'int') -&gt; 'list[int]': index1 = 0 index2 = len(numbers) - 1 while numbers[index1] + numbers[index2] != target: if numbers[index1] + numbers[index2] &gt; target: index2 -= 1 else: index1 += 1 return [index1+1, index2+1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:166. Fraction to Recurring Decimal]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[题目概述 Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: 12Input: numerator = 1, denominator = 2Output: &quot;0.5&quot; Example 2: 12Input: numerator = 2, denominator = 1Output: &quot;2&quot; Example 3: 12Input: numerator = 2, denominator = 3Output: &quot;0.(6)&quot; 本题的难点就在如何找到无限循环小数的循环体。 以5/3为例：5/3的整数部分为int(5/3)也就是1，余数为2，然后计算小数点1位之后的数字时，实际上是把2乘以了10，也就是20再除以3，得到了6，余2。这里的6就是小数点后1位的数字。接着，再用余数2*10/3…以此类推。所以说，我们只需要一个数组，存放每一次进行除法操作后的余数，如果余数相同，则已经开始循环了。 在实现的时候，我使用的是数组而不是哈希表，主要还是因为题目需要在结果字符串中添加括号，使用数组更容易对括号的地方进行定位。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def fractionToDecimal(self, numerator: 'int', denominator: 'int') -&gt; 'str': sign = 1 if numerator/denominator &gt;= 0 else -1 numerator = abs(numerator) denominator = abs(denominator) remainder = numerator % denominator if remainder == 0: return str(int(sign * numerator / denominator)) result = "-" if sign == -1 else "" result += str(int(numerator/denominator)) result += '.' remainderList = [] while True: if remainder == 0: return result if remainder in remainderList: for i in range(len(remainderList)): if remainderList[i] == remainder: insertIndex = len(remainderList) - i resultList = list(result) resultList.insert(-insertIndex, '(') resultList.append(')') result = "".join(resultList) return result else: remainderList.append(remainder) remainder *= 10 result += str(int(remainder / denominator)) remainder = remainder % denominator]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:165. Compare Version Numbers]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[题目概述 Compare two version numbers version1 and version2.If *version1* &gt; *version2* return 1; if *version1* &lt; *version2* return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. Example 1: 12Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1 Example 2: 12Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1 Example 3: 12Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1 Example 4: 123Input: version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;Output: 0Explanation: Ignoring leading zeroes, both “01” and “001&quot; represent the same number “1” Example 5: 123Input: version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;Output: 0Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to &quot;0&quot; Note: Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. Version strings do not start or end with dots, and they will not be two consecutive dots. 这题其实不难，本质上就是把字符串根据’.’进行切割后形成两个数组，然后对两个数组的元素进行逐一比较即可。 代码实现 1234567891011121314151617181920212223class Solution: def compareVersion(self, version1: 'str', version2: 'str') -&gt; 'int': list1 = version1.split('.') list2 = version2.split('.') maxNum = min(len(list1), len(list2)) for i in range(maxNum): if int(list1[i]) &gt; int(list2[i]): return 1 elif int(list1[i]) &lt; int(list2[i]): return -1 if len(list1) &gt; len(list2): for i in range(maxNum, len(list1)): if int(list1[i]) &gt; 0: return 1 return 0 elif len(list1) == len(list2): return 0 else: for i in range(maxNum, len(list2)): if int(list2[i]) &gt; 0: return -1 return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:164. Maximum Gap]]></title>
    <url>%2F2019%2F06%2F14%2FLeetCode-164-Maximum-Gap%2F</url>
    <content type="text"><![CDATA[题目概述 Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 本题最难的地方就是要求时间和空间复杂度都为O(n) 所以本题的思路就是使用桶排序，因为这是一种时间复杂度和空间复杂度都为O(n)的排序算法。但是本题要求的不仅是排序，还需要算出数与数之间最大的Gap。 参考了网上的一些做法后，我也逐渐理清了思路。 首先，这个最大gap的值，不可能小于(maxNum-minNum)/size的值，其中maxNum和minNum为数组中的最大值和最小值，而size则为输入的数组大小。 考虑到这点，我们就可以用size+1个桶来存放nums中的所有数字。每个桶的大小为(maxNum-minNum)/size，存放的桶的索引值则为(i-minNum)/size。这样，我们就只需要找到每个桶的最大值和最小值，并且来比较桶与桶之间的最大Gap，这个最大Gap就是整个数组的最大Gap。（因为桶内的两个数的最大Gap不可能成为全局最大Gap） 由于不需要进行数与数之间的比较，本算法的时间复杂度和空间复杂度都是线性的。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) &#123; return 0; &#125; int maxNum = INT_MIN; int minNum = INT_MAX; for (auto i:nums) &#123; if (i &lt; minNum) &#123; minNum = i; &#125; if (i &gt; maxNum) &#123; maxNum = i; &#125; &#125; if (maxNum == minNum) return 0; int len = nums.size(); int bucketSize = ceil((double)(maxNum-minNum)/nums.size()); int bucketNum = nums.size()+1; vector&lt;vector&lt;int&gt;&gt; bucket(bucketNum); for (auto i:bucket) &#123; i.resize(0); &#125; for (auto i:nums) &#123; int index = (i-minNum)/bucketSize; bucket[index].push_back(i); &#125; int result = INT_MIN; vector&lt;bool&gt; isValid(bucketNum); vector&lt;int&gt; bucketMin(bucketNum); vector&lt;int&gt; bucketMax(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; if (bucket[i].size() &gt; 0)&#123; isValid[i] = true; int tmpMin = INT_MAX; int tmpMax = INT_MIN; for (int j = 0; j &lt; bucket[i].size(); j++)&#123; if (bucket[i][j] &lt; tmpMin) tmpMin = bucket[i][j]; if (bucket[i][j] &gt; tmpMax) tmpMax = bucket[i][j]; &#125; bucketMin[i] = tmpMin; bucketMax[i] = tmpMax; &#125; else &#123; isValid[i] = false; &#125; &#125; int lastMax = bucketMax[0]; for (int i = 1; i &lt; bucketNum; i++) &#123; if (!isValid[i]) continue; result = result &gt; bucketMin[i] - lastMax ? result : bucketMin[i] - lastMax; lastMax = bucketMax[i]; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:160. Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目概述 Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: 123Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3Output: Reference of the node with value = 8Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: 123Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Reference of the node with value = 2Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: 1234Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: nullInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 本题的思路就是对两个链表进行从头到尾的遍历，并且将所得的地址存在两个vector中，然后从后往前比较vector，找到第一个不同的地址的索引，该索引+1就是两个链表的交点地址。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; vector&lt;struct ListNode *&gt; vector1; vector&lt;struct ListNode *&gt; vector2; while (headA != nullptr)&#123; vector1.push_back(headA); headA = headA-&gt;next; &#125; vector1.push_back(nullptr); while (headB != nullptr)&#123; vector2.push_back(headB); headB = headB-&gt;next; &#125; vector2.push_back(nullptr); int i = 1; int maxNum = vector1.size() &gt; vector2.size()? vector2.size(): vector1.size(); for (i = 1; i &lt;= maxNum; i++)&#123; if (vector1[vector1.size()-i] != vector2[vector2.size()-i])&#123; break; &#125; &#125; return vector1[vector1.size()-i+1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:155. Min Stack]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目概述 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. getMin() — Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 本题的解法就是要实现两个栈。其中一个栈用来存放原数据信息，第二个栈用来存放当前栈的最小值。第二个栈的栈顶是当前栈的最小值。在进行push和pop的时候，对第一个栈进行常规操作，当push的值小于第二个栈的栈顶时，要将该值也push进第二个栈；如果pop出的值为第二个栈的栈顶元素时，也需要对第二个栈进行pop操作。 代码实现 1234567891011121314151617181920212223242526272829303132333435class MinStack &#123;private: stack&lt;int&gt; itemStack; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if (minStack.empty() || minStack.top() &gt;= x)&#123; itemStack.push(x); minStack.push(x); &#125; else &#123; itemStack.push(x); &#125; &#125; void pop() &#123; if (itemStack.top() == minStack.top())&#123; itemStack.pop(); minStack.pop(); &#125; else &#123; itemStack.pop(); &#125; &#125; int top() &#123; return itemStack.top(); &#125; int getMin() &#123; return minStack.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12Input: [1,3,5]Output: 1 Example 2: 12Input: [2,2,2,0,1]Output: 0 同理LeetCode: 153. Find Minimum in Rotated Sorted Array 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12Input: [3,4,5,1,2] Output: 1 Example 2: 12Input: [4,5,6,7,0,1,2]Output: 0 由于输入的数组是通过有序的数组进行旋转后得到的，因此在从左向右遍历的时候，突然变小的那个数字一定是全局最小值 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:152. Maximum Product Subarray]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-152-Maximum-Product-Subarray%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 本题和之前求连续子序列的最大和的那题很像。但是乘法与加法不同，还需要考虑两个负数的乘积很大的情况。 在这里，我用的解法是动态规划。对于序列nums，为了求解出最大的连续子序列的最大乘积，需要维护三个数组，分别为max_local, min_local和max_global。max_local[i]的含义是，以索引为i结束的连续子序列的乘积最大值；min_local[i]的含义是，以索引为i结束的连续子序列的乘积最小值，max_global[i]为到索引i为止，全局的乘积最大值。其中max_local[0], min_local[0]以及max_global[0]都为nums[0]。动态规划的状态转移公式为： 123max_local[i] = max(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])min_local[i] = min(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])max_global[i] = max(max_local[i], max_global[i-1]) 代码实现 12345678910111213141516171819class Solution: def maxProduct(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 max_local = [0] * len(nums) min_local = [0] * len(nums) max_global = [0] * len(nums) max_local[0] = nums[0] min_local[0] = nums[0] max_global[0] = nums[0] for i in range(1, len(nums)): max_local[i] = max(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) min_local[i] = min(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) max_global[i] = max(max_global[i-1], max_local[i]) return max_global[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:151. Reverse Words in a String]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[题目概述 Given an input string, reverse the string word by word. Example 1: 12Input: &quot;the sky is blue&quot;Output: &quot;blue is sky the&quot; Example 2: 123Input: &quot; hello world! &quot;Output: &quot;world! hello&quot;Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: 123Input: &quot;a good example&quot;Output: &quot;example good a&quot;Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. 本题用python实现的话其实挺简单的，直接用strip和split方法就可以 代码实现 1234567891011class Solution: def reverseWords(self, s: str) -&gt; str: s = s.strip() s_list = s.split(" ") result = "" for i in range(len(s_list)-1, -1, -1): if s_list[i] == "": continue result += " "+s_list[i] return result[1:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[题目概述 Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 123Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9 Example 2: 123Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6 Example 3: 12345678910Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 本题就是要实现一个简单的stack，当输入为数字的时候进行push操作，对于操作符则需要pop出两个数字，并且进行计算，最后返回stack中的唯一元素即可。 代码实现 12345678910111213141516171819202122232425262728class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for item in tokens: if item == "+": num1 = stack.pop() num2 = stack.pop() stack.append(num1+num2) elif item == "-": num1 = stack.pop() num2 = stack.pop() stack.append(num2-num1) elif item == "*": num1 = stack.pop() num2 = stack.pop() stack.append(num1*num2) elif item == "/": num1 = stack.pop() num2 = stack.pop() stack.append(int(num2/num1)) else: stack.append(int(item)) return stack[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:149. Max Points on a Line]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[题目概述 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: 12345678910Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4 Example 2: 1234567891011Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. 这题比较坑，而且这个hard难度考察的也并不是算法。这题目最直观的想法是通过求两点的直线方程后，对所有点进行遍历并记数。我们需要求到两点之间的斜率等信息。 但是，本题要考虑的还有： 如何尽量避免重复的运算 对平行于Y轴的直线的特殊处理 需要考虑除法带来的一些计算问题：计算机内部的除法得到的值并非是一个分数，而是一个有限小数。比如对于[1,1]、[4,2]两点，通过求解得到的斜率不是正好的1/3，而是类似0.33333的有限小数，因此尽管点[7,3]在这条直线上，但是使用0.33333*(7-1)+1-3得到的并不是0，而是一个很接近0的数字，因此需要尽量避免使用除法 因此，在本题中，我使用了checkMetrix来表示两个点之间是否已经经过了计算，并且使用乘法代替除法 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def __init__(self): self.checkMetrix = None def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ wordLen = len(points) self.checkMetrix = [[0] * wordLen for _ in range(wordLen)] maxCount = 0 flag = 0 for i in range(wordLen): for j in range(wordLen): if self.checkMetrix[i][j] == 1: continue if i == j: continue if points[i][0] == points[j][0] and points[i][1] == points[j][1]: continue maxCount = max(self.countPoints(i, j, points), maxCount) flag = 1 if flag == 0: return wordLen else: return maxCount def countPoints(self, index1, index2, points): point1 = points[index1] point2 = points[index2] count = 0 if point1[0] == point2[0]: for i in range(len(points)): if points[i][0] == point1[0]: self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 else: for i in range(len(points)): if (point1[1] - point2[1]) * (points[i][0]-point1[0]) == (points[i][1] - point1[1]) * (point1[0] - point2[0]): self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 return count l]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
