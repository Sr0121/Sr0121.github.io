<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:181. Employees Earning More Than Their Managers]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-181-Employees-Earning-More-Than-Their-Managers%2F</url>
    <content type="text"><![CDATA[题目描述 The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. 12345+----------+| Employee |+----------+| Joe |+----------+ 在where语句中查找出每行对应的manager的salary后进行比较即可。 代码实现 123select s.name as Employeefrom Employee as swhere s.Salary &gt; (select t.Salary from Employee as t where t.id = s.managerid)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:179. Largest Number]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-179-Largest-Number%2F</url>
    <content type="text"><![CDATA[题目描述 Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; 题目要求对一串数组进行重新排列，让他们组合成最大的数字。比如[10,2]排列成”210”，[3,30,34,5,9]排列成”9534330”。 我们需要对每个字符的位数依次比较，比如[3,30,34,5,9]，第一位最大的是9，那么9就一定排在第一个，第一位第二大的是5，那么5就排在第二个，第三大的是3，然后就比第二位，于是第三个数字就是34…事实上，对于字符串a和b来说，如果a+b大于b+a，那么在最终排列的时候，a一定排在b的前面。 因此只需要实现一个compare函数，利用python内置的sort进行快排，就可以很快地得到我们需要的排序结果。最后注意要删除最左边的”0”，以及确保字符串不为空 代码实现 12345678910111213141516171819202122from functools import cmp_to_keyclass Solution: def largestNumber(self, nums: List[int]) -&gt; str: def compare(x, y): if int(str(x)+str(y)) &gt; int(str(y)+str(x)): return 1 elif int(str(x)+str(y)) &lt; int(str(y)+str(x)): return -1 else: return 0 nums = sorted(nums, key=cmp_to_key(compare)) result = "" for i in range(len(nums)-1, -1, -1): result += str(nums[i]) result = result.lstrip("0") result = "0" if result == "" else result return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:178. Rank Scores]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-178-Rank-Scores%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks. 12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ For example, given the above Scores table, your query should generate the following report (order by highest score): 12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ 这题的思路就是构建一张空的表格t，该表格中的score分数由原表格s生成，但是score唯一。 然后比较两张表格。对于每个s中的分数，需要统计t中比s的score更大或相等的数字有几个。 这里要注意的就是需要加上group by s.id的语句，这里的group by的功能大概就是为了在输出的时候，确定每个id都输出的意思。不加group by则只会输出一行。 代码实现 1234567select s.Score, count(t.Score) as Rankfrom Scores as s,(select distinct Score from Scores) as t where s.Score &lt;= t.scoregroup by s.idorder by s.Score desc;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:177. Nth Highest Salary]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-177-Nth-Highest-Salary%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to get the nth highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. 12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ 这里需要使用函数实现查询第N大的salary，考察的是对limit的使用。 limit n, m表示除去前n项后，再输出m项，因此在这里需要limit N-1, 1就可以满足要求。但是由于limit语句中不能做算术操作，因此要将N-1赋值给另外一个变量后M后，再使用limit M, 1。 赋值的时候注意SQL是大小写不敏感的。 代码实现 123456789CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINdeclare M int;set M = N-1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary desc limit M, 1 );END]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:176. Second Highest Salary]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-176-Second-Highest-Salary%2F</url>
    <content type="text"><![CDATA[题目描述 Write a SQL query to get the second highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 查找第二大的元素，只需要在where语句中过滤掉最大的元素后再使用max即可 代码实现 1select max(Salary) as SecondHighestSalary from Employee where Salary &lt; (select max(Salary) from Employee)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:219. Contains Duplicate II]]></title>
    <url>%2F2019%2F07%2F03%2FLeetCode-219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: 12Input: nums = [1,2,3,1], k = 3Output: true Example 2: 12Input: nums = [1,0,1,1], k = 1Output: true Example 3: 12Input: nums = [1,2,3,1,2,3], k = 2Output: false 这题需要找数组中存在nums[i] == nums[j]，并且i和j的差的绝对值小于等于k。 这里需要用一个字典进行存储，字典的键为nums[i]，值为i。从左到右遍历数组nums，如果nums[i]没有出现在字典的键中，则添加nums[i]到字典里。如果字典中已经有nums[i]，则将比较i与该键所对应的值的差值，如果小于k则返回True，否则更新该值。 代码实现 123456789101112class Solution: def containsNearbyDuplicate(self, nums: 'list[int]', k: 'int') -&gt; 'bool': M = &#123;&#125; for i in range(len(nums)): if nums[i] not in M.keys(): M[nums[i]] = i else: if i - M[nums[i]] &lt;= k: return True else: M[nums[i]] = i return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:218. The Skyline Problem]]></title>
    <url>%2F2019%2F07%2F02%2FLeetCode-218-The-Skyline-Problem%2F</url>
    <content type="text"><![CDATA[题目描述 A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Riare the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]. The output is a list of “key points“ (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ]that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] 题目需要让我们求出几个长方形组成的轮廓，返回的点唯一确定这个轮廓。从B图中可以发现，所有返回的点实际上为轮廓高度的突变点。而所有可能的突变点，均为长方形竖着的边。为了做区分，我把左边的边称为开始边，右边的边称为结束边。 因此，我们需要从左向右遍历矩形的开始边盒结束边，并且记录当前的最高点的高度。所以我们需要维护一个有序的list，当遍历到的边为开始边时，把开始边的高度增加到这个有序列表中，如果是结束边，则把该边的高度从列表中删除。 在实际操作的时候，我们需要把[Li, Ri, Hi]分解为[Li, -Hi]和[Ri, Hi]，然后统一存放到同一个数组中，并且根据Li和Ri的值进行无差别的排列。这样可以方便之后从左向右进行遍历，并且在遍历的同时能区分开始边和结束边。 在网上的一些方法中，有人使用了MaxHeap，这个堆可以很快地返回最大值，并且可以很方便地进行删除和增加操作，时间复杂度为O(n)。但是Python中需要对其进行额外实现，然而直接使用快速排序维持一个有序列表的方法也能通过OJ，所以在这里我就只是用了快速排序。 代码实现 123456789101112131415161718192021222324252627282930313233343536import functoolsclass Solution: def getSkyline(self, buildings: 'list[list[int]]') -&gt; 'list[list[int]]': def cmp(x, y): if x[0] != y[0]: return x[0] - y[0] else: return x[1] - y[1] nodes = [] result = [] if len(buildings) == 0: return result for i in buildings: nodes.append([i[0], -i[2]]) nodes.append([i[1], i[2]]) nodes = sorted(nodes, key=functools.cmp_to_key(cmp)) peak = 0 peaks = [0] for i in nodes: if i[1] &lt; 0: peaks.append(-i[1]) peaks = sorted(peaks) else: peaks.remove(i[1]) current = peaks[-1] if current != peak: result.append([i[0], current]) peak = current return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:216. Combination Sum III]]></title>
    <url>%2F2019%2F07%2F01%2FLeetCode-216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[题目描述 Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12Input: k = 3, n = 7Output: [[1,2,4]] Example 2: 12Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] 使用DFS查找可以很快找到所有的组合。 代码实现 1234567891011121314151617181920212223import copyclass Solution: def combinationSum3(self, k: int, n: int) -&gt; 'list[list[int]]': def dfs(current, sum): if len(current) == k and sum == n: result.append(copy.deepcopy(current)) return if sum &gt;= n or len(current) &gt;= k: return start = 1 if len(current) == 0 else current[-1] + 1 for i in range(start, 10, 1): sum += i current.append(i) dfs(current, sum) sum -= i current.pop() result = [] dfs([], 0) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:214. Shortest Palindrome]]></title>
    <url>%2F2019%2F06%2F29%2FLeetCode-214-Shortest-Palindrome%2F</url>
    <content type="text"><![CDATA[题目描述 Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: 12Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot; Example 2: 12Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot; 给定一个字符串，我们需要在字符串的开头添加若干字符串，使新的字符串成为回文的字符串。比如“abcd”变成“dcbabcd”；“aacecaaa”变成“aaacecaaa” 如果一个字符串A可以表示为BS，其中B和S非空，那么B就是A的在该字符串中的前缀，S为字符串的后缀。这一题的核心就是去求该字符串回文前缀有多长，比如“aacecaaa”的回文前缀最长为“aacecaa”，我们就只需要再补一个“a”，与最后一个字符“a”对应就可以了。 如果对长度为n的字符串从第0个位置到第n/2个位置分别判断是否为回文字符串，那么其时间复杂度是n^2。 但是这里我们会使用KMP算法中的next数组。next数组存储了每一个索引之前的子字符串的前缀与后缀相同的最大值。 对于字符串abababca来说，当index = 5时，其之前的字符串为”ababa”，”ababa”的前缀为[“a”, “ab”, “aba”, “abab”]，后缀是[“a”, “ba”, “aba”, “baba”]，前缀和后缀中最长的相同字符串为”aba”，因此这里的next[5]就是3。 对于本题，我们的方法是将原字符串的逆序添加到原字符串的后面，因为我们要找的是字符串的前序回文字符串的最大值，那么这个回文字符串的逆序会在新生成的字符串的最后，并且与开头的这个回文字符串相同，因此本题就转化成了求解这个新生成的字符串的next。 举个例子，对于”aacecaaa”来说，我们会在它之后加一个特殊字符作为切分，然后添加它的逆字符串，生成”aacecaaa#aaacecaa”，并且在最后再加上一位，让next[-1]能表示新增一位的前面的所有字符。最终生成的字符串为”aacecaaa#aaacecaa*”。对于next[-1]来说，其对应的子字符串为”aacecaaa#aaacecaa”的前缀和后缀相同的字符串的长度，也就是“aacecaa”，长度为7，这样就找到了原字符串的最长回文前缀了。 KMP算法的next数组可以帮助我们很快找到字符串的前缀和后缀的相同字符串。next的求法如下所示： 123456789101112131415def getNext(self, p): next = [0] * len(p) next[0] = -1 i = 0 j = next[0] while i &lt; len(p)-1: if j == -1 or p[i] == p[j]: i += 1 j += 1 next[i] = j else: j = next[j] return next 其核心思想就是维护两个索引，其中i为next的下一个需要求的索引，j为最长的回文前缀的索引。由于next保存了i之前的前缀和后缀的最大相同值，因此让j=next[i]，可以保证其i+1的最长相同值不大于j。 代码实现 123456789101112131415161718192021222324252627282930313233class Solution: def shortestPalindrome(self, s: str) -&gt; str: newS = s + '#' for i in range(len(s)-1, -1, -1): newS += s[i] newS += "*" next = self.getNext(newS) index = next[-1] result = "" for i in range(len(s)-1, index-1, -1): result += s[i] result += s return result def getNext(self, p): next = [0] * len(p) next[0] = -1 i = 0 j = next[0] while i &lt; len(p)-1: if j == -1 or p[i] == p[j]: i += 1 j += 1 next[i] = j else: j = next[j] return next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:213. House Robber II]]></title>
    <url>%2F2019%2F06%2F27%2FLeetCode-213-House-Robber-II%2F</url>
    <content type="text"><![CDATA[题目描述 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. 本题是之前House Robber的升级版。在这里，所有的房子形成一个环形，言下之意就是第一个房子和最后一个房子不能都偷。 假设有n个房子，他们的财产为house[0], house[1], …, house[n-1]，要保证house[0]和house[n-1]都不被偷，并且求出能偷的最大值。如果不偷house[n-1]，那么就转化成了House Robber中的house[0], …, house[n-2]的情形；同理，如果不偷house[0]，那么就转化成了求house[1], …, house[n-1]的情形。因此，本题就是求House Robber中的house[0], …, house[n-2]和house[1], …, house[n-1]的最大值。 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution: def rob1(self, nums) -&gt; 'list[int]': if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp def rob2(self, nums) -&gt; 'list[int]': if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[len(nums)-1] = nums[len(nums)-1] dp[len(nums)-2] = max(nums[len(nums)-1], nums[len(nums)-2]) for i in range(len(nums)-3, -1, -1): dp[i] = max(dp[i+1], dp[i+2] + nums[i]) return dp def rob(self, nums: 'list[int]') -&gt; 'int': if len(nums) &lt;= 2: return max(nums) dp1 = self.rob1(nums) dp2 = self.rob2(nums) return max(dp1[-2], dp2[1])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:212. Word Search II]]></title>
    <url>%2F2019%2F06%2F26%2FLeetCode-212-Word-Search-II%2F</url>
    <content type="text"><![CDATA[题目描述 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: 12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] Note: All inputs are consist of lowercase letters a-z. The values of words are distinct. 这题我一开始尝试暴力搜索，需要对所有字符串，board的长和宽都进行一次循环遍历。最后出了很多bug，而且超时。 后来查阅了网上的一些资料，才知道这题也要使用之前的Trie树来进行搜索。这样可以减少一层的循环。 所以一开始，需要把word里的所有字符串存到Trie中，然后对board中的所有元素依此进行深度优先搜索，查找当前的字符是否在Trie当前节点的子节点中，如果没有则直接返回，如果有，则让当前Trie的节点变为该子节点，然后查找当前字符的上下左右四个相邻的字符是否在新的Trie节点的子节点中，以此类推，实现一个深度优先搜索。如果当前节点是某个Trie中的字符串的结束字符，则将该字符串存入结果中，最终返回结果。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node: def __init__(self, val): self.val = val self.next = [None] * 26 self.end = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.start = Node("") def insert(self, word: str) -&gt; None: """ Adds a word into the data structure. """ this = self.start for i in range(len(word)): index = ord(word[i]) - ord('a') if this.next[index] == None: this.next[index] = Node(this.val + word[i]) this = this.next[index] this.end = Trueclass Solution: def findWords(self, board: 'list[list[str]]', words: 'list[str]') -&gt; 'list[str]': def dfs(root, x, y): if isVisited[x][y] == 1: return if root.end == True: result.append(root.val) root.end = False isVisited[x][y] = 1 direct = [[0, 1], [1, 0], [0, -1], [-1, 0]] for dir in direct: newx = x + dir[0] newy = y + dir[1] if newx &lt; 0 or newx &gt;= len(board) or newy &lt; 0 or newy &gt;= len(board[0]): continue if root.next[ord(board[newx][newy]) - ord('a')] != None: dfs(root.next[ord(board[newx][newy]) - ord('a')], newx, newy) isVisited[x][y] = 0 trie = Trie() for word in words: trie.insert(word) result = [] if len(board) == 0 or len(board[0]) == 0: return result isVisited = [[0] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if trie.start.next[ord(board[i][j]) - ord('a')] != None: dfs(trie.start.next[ord(board[i][j]) - ord('a')], i, j) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:211. Add and Search Word - Data structure design]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-211-Add-and-Search-Word-Data-structure-design%2F</url>
    <content type="text"><![CDATA[题目描述 Design a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 本题就是要实现一个数据结构，可以进行增加字符串和查找功能，这里的查找功能可以是模糊查找。 本题的数据结构与之前的Trie一致，但是查找方面不同。这里的查找使用DFS，如果出现要匹配’.’，则需要在所有的子树上进行查找，任意子树返回True，则为匹配成功。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node: def __init__(self, val): self.val = val self.next = [] self.end = Falseclass WordDictionary: def __init__(self): """ Initialize your data structure here. """ self.start = Node(-1) def addWord(self, word: str) -&gt; None: """ Adds a word into the data structure. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: newNode = Node(word[index]) this.next.append(newNode) this = newNode index += 1 this.end = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. """ return self.dfs(word, self.start, 0) def dfs(self, word, node, index): if index == len(word): return node.end if word[index] == '.': for i in node.next: if self.dfs(word, i, index+1): return True return False else: for i in node.next: if i.val == word[index] and self.dfs(word, i, index+1): return True return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:209. Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-209-Minimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[题目描述 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example: 123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 题目要求在一串数字中找到最短的连续数字，让他们的和大于给定的正数。 这里需要记录数组的开始和结尾的索引，并且需要记录连续的数字之和。每当数字比给定目标小的时候，右边的索引要往右移动，其他情况则左边索引向右移动一格，并且如果比最小的结果更小的时候需要记录这个长度。 代码实现 123456789101112131415161718192021222324252627class Solution: def minSubArrayLen(self, s: int, nums: 'list[int]') -&gt; int: if len(nums) == 0: return 0 start = 0 end = 1 sum = nums[0] result = len(nums) find = False while True: if sum &gt;= s: find = True result = end - start if end - start &lt; result else result if start &lt; len(nums)-1: sum -= nums[start] start += 1 else: break else: if end &lt; len(nums): sum += nums[end] end += 1 else: break return 0 if find == False else result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:208. Implement Trie (Prefix Tree)]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-208-Implement-Trie-Prefix-Tree%2F</url>
    <content type="text"><![CDATA[题目描述 Implement a trie with insert, search, and startsWith methods. Example: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Trie树能够存储字符串，它的每一个节点都代表了一个字母，结构如下所示： 上图中，存放了at、bee、ben、bt、q五个字符串。其中绿色代表着字符串的结束，它可以出现在树的非叶子节点。 因此对于每个节点，需要存放其值，子节点以及是否位字符串的结束，其定义如下： 12345class Node: def __init__(self, val): self.val = val self.next = [] self.end = False 在进行insert(‘bed’)的时候，会从最顶的节点开始向下查找，如果查找到’b’，那么就会在这个’b’节点继续往下查找’e’，如果也有的话继续在’e’查找’d’ 。但是如果一开始没有查找到’b’，则会新创建一个节点’b’，然后在这个新节点下面继续查找’e’（虽然一定是找不到的），找不到的话创建’e’ ，以此类推。 在进行search的时候，也会从头节点开始向下进行查找，但是如果找不到，那么会直接返回False。如果完整地找到了这个字符串，还需要看该字符串的最后一个节点的end是否为True，如果是则返回True，否则返回False。 startswith操作和search操作基本一致，但是它不需要检查字符串的最后一个节点的end状态。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Node: def __init__(self, val): self.val = val self.next = [] self.end = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.start = Node(-1) def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: newNode = Node(word[index]) this.next.append(newNode) this = newNode index += 1 this.end = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: return False if this.end == True: return True else: return False def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ this = self.start index = 0 while index &lt; len(prefix): find = False for i in this.next: if i.val == prefix[index]: find = True this = i index += 1 break if find == False: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:206. Reverse Linked List]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述 Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 用一个虚的头节点（如下的start节点）可以简化代码。 代码实现 12345678910111213141516class Solution: def reverseList(self, head: 'ListNode') -&gt; 'ListNode': if head == None: return head start = ListNode(0) start.next = head tmp = head last = start while tmp != None: nextTmp = tmp.next tmp.next = last last = tmp tmp = nextTmp head.next = None return last]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:205. Isomorphic Strings]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[题目描述 Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 12Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: true Example 2: 12Input: s = &quot;foo&quot;, t = &quot;bar&quot;Output: false Example 3: 12Input: s = &quot;paper&quot;, t = &quot;title&quot;Output: true 用了一个字符串，按顺序存放s和t的索引上的字母首次出现的位置，最后比较这两个位置是否相同。 代码实现 12345678910111213141516171819202122232425class Solution: def isIsomorphic(self, s: 'str', t: 'str') -&gt; 'bool': mapS = &#123;&#125; mapT = &#123;&#125; indexS = "" indexT = "" for i in range(len(s)): if s[i] not in mapS.keys(): mapS[s[i]] = i indexS += str(i) else: indexS += str(mapS[s[i]]) for i in range(len(t)): if t[i] not in mapT.keys(): mapT[t[i]] = i indexT += str(i) else: indexT += str(mapT[t[i]]) if indexS == indexT: return True else: return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:204. Count Primes]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-204-Count-Primes%2F</url>
    <content type="text"><![CDATA[题目描述 Count the number of prime numbers less than a non-negative number, n. Example: 123Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. 以n为121为例。本题的思想就是用数组的方法，先找2的倍数，把所有2的倍数（不包括2）进行标记。然后找接下来一个最小的没有被标记的数（3），将其倍数（不包括3）也标记起来。依此类推，一直做到11（根号121）为止。这是因为任何小于121的合数，必然会有一个因数小于11。 最后，数出没有被标记的数字的个数，就是小于121的质数的个数。 代码实现 12345678910111213141516171819class Solution: def countPrimes(self, n: 'int') -&gt; 'int': if n &lt; 3: return 0 isCount = [0] * n count = 0 for i in range(2, int(math.sqrt(n-1))+1): if isCount[i] == 0: index = i while index+i &lt; n: index += i isCount[index] = 1 for i in range(2, n): if isCount[i] == 0: count += 1 return count]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:203. Remove Linked List Elements]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[题目描述 Remove all elements from a linked list of integers that have value val. Example: 12Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 代码实现 123456789101112131415class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: start = ListNode(0) start.next = head tmp = head last = start while tmp != None: if tmp.val == val: last.next = tmp.next tmp = tmp.next else: last = last.next tmp = tmp.next return start.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:202. Happy Number]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-202-Happy-Number%2F</url>
    <content type="text"><![CDATA[题目描述 Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 1234567Input: 19Output: trueExplanation: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 快乐数就是将自己的每一位数字的平方加起来后，最终为1的数字，如果中间出现了循环，则它不是快乐数。 所以需要用一个list存放所有在计算中出现的数字，如果原数字在进行计算的时候，出现了list中的数字，则不是快乐数。 代码实现 12345678910111213141516171819class Solution: def isHappy(self, n: 'int') -&gt; 'bool': if n &lt;= 0: return False ns = [] while n is not 1: next_n = 0 if n in ns: return False ns.append(n) while n &gt; 0: next_n += (n % 10)**2 n = n // 10 n = next_n return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:201. Bitwise AND of Numbers Range]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-201-Bitwise-AND-of-Numbers-Range%2F</url>
    <content type="text"><![CDATA[题目描述 Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: 12Input: [5,7]Output: 4 Example 2: 12Input: [0,1]Output: 0 这道题目需要找到连续范围内的所有数的与，如果直接进行与的话会导致超时。 当m和n位数不同的时候，比如说m是0b11, n是0b111，由于由于他们位数不同，那么他们中一定会出现一个0b100，与m在后两位上的与都是0，所以m和n在位数不同的情况下一定是0. 当位数相同的时候，比如说m为0b11001，n为0b11100的时候，他们之间有0b11010，0b11011，可以看出，他们这些数字的头两位都是一样的，而后几位的与都为0. 因此，本题也就是要求解m和n的二进制表达下的头几位是相同的。考虑到之前的m和n位数不同的时候，m的头几位可以用0来补足，因此之前的特殊情况也符合该描述。 代码实现 1234567891011121314151617class Solution: def rangeBitwiseAnd(self, m: 'int', n: 'int') -&gt; 'int': tmp = n bits = 0 if m == n: return m while tmp &gt; 0: tmp = tmp &gt;&gt; 1 bits = bits*2 + 1 count = 1 while bits &amp; n != bits &amp; m: bits = bits &gt;&gt; count bits = bits &lt;&lt; count count += 1 return bits &amp; m]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:200. Number of Islands]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[题目描述 Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 1234567Input:11110110101100000000Output: 1 Example 2: 1234567Input:11000110000010000011Output: 3 这题需要一个额外的二维数组，来记录某一个点是否被检查过。然后我们需要对所有的点按顺序进行一次深度优先搜索，如果说这个点已经被检查过，则不再搜索。那么，一开始需要进行搜索的点的个数，就是岛屿的数量。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def __init__(self): self.count = 0 self.matrix = None def numIslands(self, grid: 'list[list[str]]') -&gt; 'int': if len(grid) == 0: return 0 if len(grid[0]) == 0: return 0 self.matrix = [[0] * len(grid[0]) for _ in range(len(grid))] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1' and self.matrix[i][j] == 0: self.count += 1 self.dfs(i, j, grid) return self.count def dfs(self, x, y, grid): if grid[x][y] == '1': self.matrix[x][y] = 1 if x &gt; 0 and self.matrix[x-1][y] == 0: self.dfs(x-1, y, grid) if y &gt; 0 and self.matrix[x][y-1] == 0: self.dfs(x, y-1, grid) if x &lt; len(grid)-1 and self.matrix[x+1][y] == 0: self.dfs(x+1, y, grid) if y &lt; len(grid[0])-1 and self.matrix[x][y+1] == 0: self.dfs(x, y+1, grid)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:199. Binary Tree Right Side View]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目描述 Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 这题很像之前的按照行来对树进行遍历，就是用一个类似先用一个queue来存放头节点，对queue中的所有元素的left和right进行检查，如果不是None的话就存放到另一个tmp_queue中，直到遍历完queue中的所有元素为止。接着把tmp_queue赋值给queue，进行新的一层的遍历。 所以只需要记录每一次的tmp_queue的最后一个元素即可。 代码实现 1234567891011121314151617181920class Solution: def rightSideView(self, root: 'TreeNode') -&gt; 'list[int]': result = [] if root == None: return result queue = [root] result.append(root.val) while len(queue) &gt; 0: tmp = [] for i in queue: if i.left != None: tmp.append(i.left) if i.right != None: tmp.append(i.right) if len(tmp) &gt; 0: result.append(tmp[-1].val) queue = tmp return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:198. House Robber]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[题目描述 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: 1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 这题就是一个很明显的动态规划。由于两次偷盗的索引不能相邻，因此某个索引的偷盗最大值为上个索引的偷盗最大值或上上个索引的偷盗值加上当前nums的值，即dp[i] = max(dp[i-1], dp[i-2] + nums[i]) 代码实现 1234567891011121314class Solution: def rob(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 dp = [0] * len(nums) dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(dp)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:174. Dungeon Game]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-174-Dungeon-Game%2F</url>
    <content type="text"><![CDATA[题目概述 The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3 -5 -10 1 10 30 -5 (P) Note: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 这道题目翻译一下，就是要保证这个骑士在走过每一个格子之后，血量至少为1。这题可以用动态规划来进行求解。如果一个格子上的数字为-5，那么骑士在踏上这个格子的时候，至少需要max(1, 1-(-5)) = 6点血量；如果格子上的数字为5，那么骑士只需要max(1, 1-5) = 1点血量。 接着需要考虑周围格子的情况。如果某个格子的右边的格子至少需要有4点血量，另一个格子至少要3点血量，那么在经过这个格子之后，我们需要至少保留min(4, 3) = 3点血量。 那么，状态转移公式就是dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) 代码实现 12345678910111213141516171819class Solution: def calculateMinimumHP(self, dungeon: 'list[list[int]]') -&gt; 'int': row = len(dungeon) column = len(dungeon[0]) dp = [[0] * column for _ in range(row)] dp[row-1][column-1] = max(1 - dungeon[row-1][column-1], 1) for i in range(column-2, -1, -1): dp[row-1][i] = max(dp[row-1][i+1] - dungeon[row-1][i], 1) for i in range(row - 2, -1, -1): dp[i][column - 1] = max(dp[i + 1][column - 1] - dungeon[i][column - 1], 1) for i in range(row - 2, -1, -1): for j in range(column - 2, -1, -1): dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) return dp[0][0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:173. Binary Search Tree Iterator]]></title>
    <url>%2F2019%2F06%2F17%2FLeetCode-173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[题目概述 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: 12345678910BSTIterator iterator = new BSTIterator(root);iterator.next(); // return 3iterator.next(); // return 7iterator.hasNext(); // return trueiterator.next(); // return 9iterator.hasNext(); // return trueiterator.next(); // return 15iterator.hasNext(); // return trueiterator.next(); // return 20iterator.hasNext(); // return false Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. 这题我使用了一个DFS来遍历BST，并且把按顺序把树的节点存到了self.nodes的list中。这个类同时还保存了一个当前对象在self.nodes的索引值，如果使用了next方法，就把这个索引值加一，hasnext则判断这个索引值和self.nodes的长度的关系 代码实现 12345678910111213141516171819202122232425262728class BSTIterator: def __init__(self, root: TreeNode): self.nodes = [] self.dfs(root) self.index = -1 def next(self) -&gt; int: """ @return the next smallest number """ self.index += 1 return self.nodes[self.index].val def hasNext(self) -&gt; bool: """ @return whether we have a next smallest number """ if self.index &lt; len(self.nodes) - 1: return True else: return False def dfs(self, root): if root == None: return self.dfs(root.left) self.nodes.append(root) self.dfs(root.right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:172. Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer n, return the number of trailing zeroes in n!. Example 1: 123Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: 123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. 在阶乘中，只有5的倍数能产生0，因此这道题就转化成了n!的因子中有多少个5. 这里需要注意的是，25，125这种数字包含了多个5，需要进行重复计算。 代码实现 12345678class Solution: def trailingZeroes(self, n: int) -&gt; int: divisor = 5 result = 0 while divisor &lt;= n: result += n // divisor divisor *= 5 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:171. Excel Sheet Column Number]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-171-Excel-Sheet-Column-Number%2F</url>
    <content type="text"><![CDATA[题目概述 Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... Example 1: 12Input: &quot;A&quot;Output: 1 Example 2: 12Input: &quot;AB&quot;Output: 28 Example 3: 12Input: &quot;ZY&quot;Output: 701 进制转换的题目 代码实现 12345678class Solution: def titleToNumber(self, s: 'str') -&gt; 'int': result = 0 for i in range(len(s)): result *= 26 result += ord(s[i]) - 64 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:169. Majority Element]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-169-Majority-Element%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 12Input: [3,2,3]Output: 3 Example 2: 12Input: [2,2,1,1,1,2,2]Output: 2 题目要求找到数组中的众数。我是把数组进行排序后从左到右找，如果当前数字和之前的数字一样，就会给一个记录值加一，如果发现当前数字与其之前的数字不一样，则把记录值和全局最大值进行比较。 代码实现 123456789101112131415161718192021class Solution: def majorityElement(self, nums: 'list[int]') -&gt; 'int': nums = sorted(nums) if len(nums) == 1: return nums[0] maxNum = 1 tmpNum = 1 targetIndex = 0 for i in range(1, len(nums)): if nums[i] == nums[i-1]: tmpNum += 1 elif i &lt; len(nums): if tmpNum &gt;= maxNum: targetIndex = i-1 maxNum = tmpNum tmpNum = 1 if i == len(nums)-1 and tmpNum &gt;= maxNum: targetIndex = i return nums[targetIndex]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:168. Excel Sheet Column Title]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-168-Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[题目概述 Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... Example 1: 12Input: 1Output: &quot;A&quot; Example 2: 12Input: 28Output: &quot;AB&quot; Example 3: 12Input: 701Output: &quot;ZY&quot; 进制转换的题目 代码实现 1234567891011class Solution: def convertToTitle(self, n: 'int') -&gt; 'str': result = "" while True: remainder = (n-1) % 26 n = int((n-1)/26) result = chr(65+remainder) + result if n == 0: break return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 简单题，由于数组是递增的，所以一开始假定index1为0，index2为数组的最后一个索引，如果对应的两个数相加比target小，则让index1加一，反之让index2减1，直到找到两个和为target的值的索引 最后注意把求得的index+1即可。 代码实现 123456789101112class Solution: def twoSum(self, numbers: 'list[int]', target: 'int') -&gt; 'list[int]': index1 = 0 index2 = len(numbers) - 1 while numbers[index1] + numbers[index2] != target: if numbers[index1] + numbers[index2] &gt; target: index2 -= 1 else: index1 += 1 return [index1+1, index2+1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:166. Fraction to Recurring Decimal]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[题目概述 Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: 12Input: numerator = 1, denominator = 2Output: &quot;0.5&quot; Example 2: 12Input: numerator = 2, denominator = 1Output: &quot;2&quot; Example 3: 12Input: numerator = 2, denominator = 3Output: &quot;0.(6)&quot; 本题的难点就在如何找到无限循环小数的循环体。 以5/3为例：5/3的整数部分为int(5/3)也就是1，余数为2，然后计算小数点1位之后的数字时，实际上是把2乘以了10，也就是20再除以3，得到了6，余2。这里的6就是小数点后1位的数字。接着，再用余数2*10/3…以此类推。所以说，我们只需要一个数组，存放每一次进行除法操作后的余数，如果余数相同，则已经开始循环了。 在实现的时候，我使用的是数组而不是哈希表，主要还是因为题目需要在结果字符串中添加括号，使用数组更容易对括号的地方进行定位。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def fractionToDecimal(self, numerator: 'int', denominator: 'int') -&gt; 'str': sign = 1 if numerator/denominator &gt;= 0 else -1 numerator = abs(numerator) denominator = abs(denominator) remainder = numerator % denominator if remainder == 0: return str(int(sign * numerator / denominator)) result = "-" if sign == -1 else "" result += str(int(numerator/denominator)) result += '.' remainderList = [] while True: if remainder == 0: return result if remainder in remainderList: for i in range(len(remainderList)): if remainderList[i] == remainder: insertIndex = len(remainderList) - i resultList = list(result) resultList.insert(-insertIndex, '(') resultList.append(')') result = "".join(resultList) return result else: remainderList.append(remainder) remainder *= 10 result += str(int(remainder / denominator)) remainder = remainder % denominator]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:165. Compare Version Numbers]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[题目概述 Compare two version numbers version1 and version2. If *version1* &gt; *version2* return 1; if *version1* &lt; *version2* return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. Example 1: 12Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1 Example 2: 12Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1 Example 3: 12Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1 Example 4: 123Input: version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;Output: 0Explanation: Ignoring leading zeroes, both “01” and “001&quot; represent the same number “1” Example 5: 123Input: version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;Output: 0Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to &quot;0&quot; Note: Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. Version strings do not start or end with dots, and they will not be two consecutive dots. 这题其实不难，本质上就是把字符串根据’.’进行切割后形成两个数组，然后对两个数组的元素进行逐一比较即可。 代码实现 1234567891011121314151617181920212223class Solution: def compareVersion(self, version1: 'str', version2: 'str') -&gt; 'int': list1 = version1.split('.') list2 = version2.split('.') maxNum = min(len(list1), len(list2)) for i in range(maxNum): if int(list1[i]) &gt; int(list2[i]): return 1 elif int(list1[i]) &lt; int(list2[i]): return -1 if len(list1) &gt; len(list2): for i in range(maxNum, len(list1)): if int(list1[i]) &gt; 0: return 1 return 0 elif len(list1) == len(list2): return 0 else: for i in range(maxNum, len(list2)): if int(list2[i]) &gt; 0: return -1 return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:164. Maximum Gap]]></title>
    <url>%2F2019%2F06%2F14%2FLeetCode-164-Maximum-Gap%2F</url>
    <content type="text"><![CDATA[题目概述 Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 本题最难的地方就是要求时间和空间复杂度都为O(n) 所以本题的思路就是使用桶排序，因为这是一种时间复杂度和空间复杂度都为O(n)的排序算法。但是本题要求的不仅是排序，还需要算出数与数之间最大的Gap。 参考了网上的一些做法后，我也逐渐理清了思路。 首先，这个最大gap的值，不可能小于(maxNum-minNum)/size的值，其中maxNum和minNum为数组中的最大值和最小值，而size则为输入的数组大小。 考虑到这点，我们就可以用size+1个桶来存放nums中的所有数字。每个桶的大小为(maxNum-minNum)/size，存放的桶的索引值则为(i-minNum)/size。这样，我们就只需要找到每个桶的最大值和最小值，并且来比较桶与桶之间的最大Gap，这个最大Gap就是整个数组的最大Gap。（因为桶内的两个数的最大Gap不可能成为全局最大Gap） 由于不需要进行数与数之间的比较，本算法的时间复杂度和空间复杂度都是线性的。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) &#123; return 0; &#125; int maxNum = INT_MIN; int minNum = INT_MAX; for (auto i:nums) &#123; if (i &lt; minNum) &#123; minNum = i; &#125; if (i &gt; maxNum) &#123; maxNum = i; &#125; &#125; if (maxNum == minNum) return 0; int len = nums.size(); int bucketSize = ceil((double)(maxNum-minNum)/nums.size()); int bucketNum = nums.size()+1; vector&lt;vector&lt;int&gt;&gt; bucket(bucketNum); for (auto i:bucket) &#123; i.resize(0); &#125; for (auto i:nums) &#123; int index = (i-minNum)/bucketSize; bucket[index].push_back(i); &#125; int result = INT_MIN; vector&lt;bool&gt; isValid(bucketNum); vector&lt;int&gt; bucketMin(bucketNum); vector&lt;int&gt; bucketMax(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; if (bucket[i].size() &gt; 0)&#123; isValid[i] = true; int tmpMin = INT_MAX; int tmpMax = INT_MIN; for (int j = 0; j &lt; bucket[i].size(); j++)&#123; if (bucket[i][j] &lt; tmpMin) tmpMin = bucket[i][j]; if (bucket[i][j] &gt; tmpMax) tmpMax = bucket[i][j]; &#125; bucketMin[i] = tmpMin; bucketMax[i] = tmpMax; &#125; else &#123; isValid[i] = false; &#125; &#125; int lastMax = bucketMax[0]; for (int i = 1; i &lt; bucketNum; i++) &#123; if (!isValid[i]) continue; result = result &gt; bucketMin[i] - lastMax ? result : bucketMin[i] - lastMax; lastMax = bucketMax[i]; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:160. Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目概述 Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: 123Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3Output: Reference of the node with value = 8Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: 123Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Reference of the node with value = 2Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: 1234Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: nullInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 本题的思路就是对两个链表进行从头到尾的遍历，并且将所得的地址存在两个vector中，然后从后往前比较vector，找到第一个不同的地址的索引，该索引+1就是两个链表的交点地址。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; vector&lt;struct ListNode *&gt; vector1; vector&lt;struct ListNode *&gt; vector2; while (headA != nullptr)&#123; vector1.push_back(headA); headA = headA-&gt;next; &#125; vector1.push_back(nullptr); while (headB != nullptr)&#123; vector2.push_back(headB); headB = headB-&gt;next; &#125; vector2.push_back(nullptr); int i = 1; int maxNum = vector1.size() &gt; vector2.size()? vector2.size(): vector1.size(); for (i = 1; i &lt;= maxNum; i++)&#123; if (vector1[vector1.size()-i] != vector2[vector2.size()-i])&#123; break; &#125; &#125; return vector1[vector1.size()-i+1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:155. Min Stack]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目概述 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 本题的解法就是要实现两个栈。其中一个栈用来存放原数据信息，第二个栈用来存放当前栈的最小值。第二个栈的栈顶是当前栈的最小值。在进行push和pop的时候，对第一个栈进行常规操作，当push的值小于第二个栈的栈顶时，要将该值也push进第二个栈；如果pop出的值为第二个栈的栈顶元素时，也需要对第二个栈进行pop操作。 代码实现 1234567891011121314151617181920212223242526272829303132333435class MinStack &#123;private: stack&lt;int&gt; itemStack; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if (minStack.empty() || minStack.top() &gt;= x)&#123; itemStack.push(x); minStack.push(x); &#125; else &#123; itemStack.push(x); &#125; &#125; void pop() &#123; if (itemStack.top() == minStack.top())&#123; itemStack.pop(); minStack.pop(); &#125; else &#123; itemStack.pop(); &#125; &#125; int top() &#123; return itemStack.top(); &#125; int getMin() &#123; return minStack.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12Input: [1,3,5]Output: 1 Example 2: 12Input: [2,2,2,0,1]Output: 0 同理LeetCode: 153. Find Minimum in Rotated Sorted Array 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12Input: [3,4,5,1,2] Output: 1 Example 2: 12Input: [4,5,6,7,0,1,2]Output: 0 由于输入的数组是通过有序的数组进行旋转后得到的，因此在从左向右遍历的时候，突然变小的那个数字一定是全局最小值 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:152. Maximum Product Subarray]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-152-Maximum-Product-Subarray%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 本题和之前求连续子序列的最大和的那题很像。但是乘法与加法不同，还需要考虑两个负数的乘积很大的情况。 在这里，我用的解法是动态规划。对于序列nums，为了求解出最大的连续子序列的最大乘积，需要维护三个数组，分别为max_local, min_local和max_global。max_local[i]的含义是，以索引为i结束的连续子序列的乘积最大值；min_local[i]的含义是，以索引为i结束的连续子序列的乘积最小值，max_global[i]为到索引i为止，全局的乘积最大值。其中max_local[0], min_local[0]以及max_global[0]都为nums[0]。动态规划的状态转移公式为： 123max_local[i] = max(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])min_local[i] = min(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])max_global[i] = max(max_local[i], max_global[i-1]) 代码实现 12345678910111213141516171819class Solution: def maxProduct(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 max_local = [0] * len(nums) min_local = [0] * len(nums) max_global = [0] * len(nums) max_local[0] = nums[0] min_local[0] = nums[0] max_global[0] = nums[0] for i in range(1, len(nums)): max_local[i] = max(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) min_local[i] = min(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) max_global[i] = max(max_global[i-1], max_local[i]) return max_global[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:151. Reverse Words in a String]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[题目概述 Given an input string, reverse the string word by word. Example 1: 12Input: &quot;the sky is blue&quot;Output: &quot;blue is sky the&quot; Example 2: 123Input: &quot; hello world! &quot;Output: &quot;world! hello&quot;Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: 123Input: &quot;a good example&quot;Output: &quot;example good a&quot;Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. 本题用python实现的话其实挺简单的，直接用strip和split方法就可以 代码实现 1234567891011class Solution: def reverseWords(self, s: str) -&gt; str: s = s.strip() s_list = s.split(" ") result = "" for i in range(len(s_list)-1, -1, -1): if s_list[i] == "": continue result += " "+s_list[i] return result[1:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[题目概述 Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 123Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9 Example 2: 123Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6 Example 3: 12345678910Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 本题就是要实现一个简单的stack，当输入为数字的时候进行push操作，对于操作符则需要pop出两个数字，并且进行计算，最后返回stack中的唯一元素即可。 代码实现 12345678910111213141516171819202122232425262728class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for item in tokens: if item == "+": num1 = stack.pop() num2 = stack.pop() stack.append(num1+num2) elif item == "-": num1 = stack.pop() num2 = stack.pop() stack.append(num2-num1) elif item == "*": num1 = stack.pop() num2 = stack.pop() stack.append(num1*num2) elif item == "/": num1 = stack.pop() num2 = stack.pop() stack.append(int(num2/num1)) else: stack.append(int(item)) return stack[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:149. Max Points on a Line]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[题目概述 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: 12345678910Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4 Example 2: 1234567891011Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. 这题比较坑，而且这个hard难度考察的也并不是算法。这题目最直观的想法是通过求两点的直线方程后，对所有点进行遍历并记数。我们需要求到两点之间的斜率等信息。 但是，本题要考虑的还有： 如何尽量避免重复的运算 对平行于Y轴的直线的特殊处理 需要考虑除法带来的一些计算问题：计算机内部的除法得到的值并非是一个分数，而是一个有限小数。比如对于[1,1]、[4,2]两点，通过求解得到的斜率不是正好的1/3，而是类似0.33333的有限小数，因此尽管点[7,3]在这条直线上，但是使用0.33333*(7-1)+1-3得到的并不是0，而是一个很接近0的数字，因此需要尽量避免使用除法 因此，在本题中，我使用了checkMetrix来表示两个点之间是否已经经过了计算，并且使用乘法代替除法 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def __init__(self): self.checkMetrix = None def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ wordLen = len(points) self.checkMetrix = [[0] * wordLen for _ in range(wordLen)] maxCount = 0 flag = 0 for i in range(wordLen): for j in range(wordLen): if self.checkMetrix[i][j] == 1: continue if i == j: continue if points[i][0] == points[j][0] and points[i][1] == points[j][1]: continue maxCount = max(self.countPoints(i, j, points), maxCount) flag = 1 if flag == 0: return wordLen else: return maxCount def countPoints(self, index1, index2, points): point1 = points[index1] point2 = points[index2] count = 0 if point1[0] == point2[0]: for i in range(len(points)): if points[i][0] == point1[0]: self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 else: for i in range(len(points)): if (point1[1] - point2[1]) * (points[i][0]-point1[0]) == (points[i][1] - point1[1]) * (point1[0] - point2[0]): self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 return count l]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
