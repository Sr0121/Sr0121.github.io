<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:208. Implement Trie (Prefix Tree)]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-208-Implement-Trie-Prefix-Tree%2F</url>
    <content type="text"><![CDATA[题目描述 1Implement a trie with insert, search, and startsWith methods. Trie树能够存储字符串，它的每一个节点都代表了一个字母，结构如下所示： 上图中，存放了at、bee、ben、bt、q五个字符串。其中绿色代表着字符串的结束，它可以出现在树的非叶子节点。 因此对于每个节点，需要存放其值，子节点以及是否位字符串的结束，其定义如下： 12345class Node: def __init__(self, val): self.val = val self.next = [] self.end = False 在进行insert(‘bed’)的时候，会从最顶的节点开始向下查找，如果查找到’b’，那么就会在这个’b’节点继续往下查找’e’，如果也有的话继续在’e’查找’d’ 。但是如果一开始没有查找到’b’，则会新创建一个节点’b’，然后在这个新节点下面继续查找’e’（虽然一定是找不到的），找不到的话创建’e’ ，以此类推。 在进行search的时候，也会从头节点开始向下进行查找，但是如果找不到，那么会直接返回False。如果完整地找到了这个字符串，还需要看该字符串的最后一个节点的end是否为True，如果是则返回True，否则返回False。 startswith操作和search操作基本一致，但是它不需要检查字符串的最后一个节点的end状态。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Node: def __init__(self, val): self.val = val self.next = [] self.end = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.start = Node(-1) def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: newNode = Node(word[index]) this.next.append(newNode) this = newNode index += 1 this.end = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ this = self.start index = 0 while index &lt; len(word): find = False for i in this.next: if i.val == word[index]: find = True this = i index += 1 break if find == False: return False if this.end == True: return True else: return False def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ this = self.start index = 0 while index &lt; len(prefix): find = False for i in this.next: if i.val == prefix[index]: find = True this = i index += 1 break if find == False: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:206. Reverse Linked List]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述 1Reverse a singly linked list. 用一个虚的头节点（如下的start节点）可以简化代码。 代码实现 12345678910111213141516class Solution: def reverseList(self, head: 'ListNode') -&gt; 'ListNode': if head == None: return head start = ListNode(0) start.next = head tmp = head last = start while tmp != None: nextTmp = tmp.next tmp.next = last last = tmp tmp = nextTmp head.next = None return last]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:205. Isomorphic Strings]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[题目描述 12345Given two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. 用了一个字符串，按顺序存放s和t的索引上的字母首次出现的位置，最后比较这两个位置是否相同。 代码实现 12345678910111213141516171819202122232425class Solution: def isIsomorphic(self, s: 'str', t: 'str') -&gt; 'bool': mapS = &#123;&#125; mapT = &#123;&#125; indexS = "" indexT = "" for i in range(len(s)): if s[i] not in mapS.keys(): mapS[s[i]] = i indexS += str(i) else: indexS += str(mapS[s[i]]) for i in range(len(t)): if t[i] not in mapT.keys(): mapT[t[i]] = i indexT += str(i) else: indexT += str(mapT[t[i]]) if indexS == indexT: return True else: return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:204. Count Primes]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-204-Count-Primes%2F</url>
    <content type="text"><![CDATA[题目描述 1Count the number of prime numbers less than a non-negative number, n. 以n为121为例。本题的思想就是用数组的方法，先找2的倍数，把所有2的倍数（不包括2）进行标记。然后找接下来一个最小的没有被标记的数（3），将其倍数（不包括3）也标记起来。依此类推，一直做到11（根号121）为止。这是因为任何小于121的合数，必然会有一个因数小于11。 最后，数出没有被标记的数字的个数，就是小于121的质数的个数。 代码实现 12345678910111213141516171819class Solution: def countPrimes(self, n: 'int') -&gt; 'int': if n &lt; 3: return 0 isCount = [0] * n count = 0 for i in range(2, int(math.sqrt(n-1))+1): if isCount[i] == 0: index = i while index+i &lt; n: index += i isCount[index] = 1 for i in range(2, n): if isCount[i] == 0: count += 1 return count]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:203. Remove Linked List Elements]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[题目描述 1Remove all elements from a linked list of integers that have value val. 代码实现 123456789101112131415class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: start = ListNode(0) start.next = head tmp = head last = start while tmp != None: if tmp.val == val: last.next = tmp.next tmp = tmp.next else: last = last.next tmp = tmp.next return start.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:202. Happy Number]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-202-Happy-Number%2F</url>
    <content type="text"><![CDATA[题目描述 123Write an algorithm to determine if a number is &quot;happy&quot;.A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. 快乐数就是将自己的每一位数字的平方加起来后，最终为1的数字，如果中间出现了循环，则它不是快乐数。 所以需要用一个list存放所有在计算中出现的数字，如果原数字在进行计算的时候，出现了list中的数字，则不是快乐数。 代码实现 12345678910111213141516171819class Solution: def isHappy(self, n: 'int') -&gt; 'bool': if n &lt;= 0: return False ns = [] while n is not 1: next_n = 0 if n in ns: return False ns.append(n) while n &gt; 0: next_n += (n % 10)**2 n = n // 10 n = next_n return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:201. Bitwise AND of Numbers Range]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-201-Bitwise-AND-of-Numbers-Range%2F</url>
    <content type="text"><![CDATA[题目描述 1Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 这道题目需要找到连续范围内的所有数的与，如果直接进行与的话会导致超时。 当m和n位数不同的时候，比如说m是0b11, n是0b111，由于由于他们位数不同，那么他们中一定会出现一个0b100，与m在后两位上的与都是0，所以m和n在位数不同的情况下一定是0. 当位数相同的时候，比如说m为0b11001，n为0b11100的时候，他们之间有0b11010，0b11011，可以看出，他们这些数字的头两位都是一样的，而后几位的与都为0. 因此，本题也就是要求解m和n的二进制表达下的头几位是相同的。考虑到之前的m和n位数不同的时候，m的头几位可以用0来补足，因此之前的特殊情况也符合该描述。 代码实现 1234567891011121314151617class Solution: def rangeBitwiseAnd(self, m: 'int', n: 'int') -&gt; 'int': tmp = n bits = 0 if m == n: return m while tmp &gt; 0: tmp = tmp &gt;&gt; 1 bits = bits*2 + 1 count = 1 while bits &amp; n != bits &amp; m: bits = bits &gt;&gt; count bits = bits &lt;&lt; count count += 1 return bits &amp; m]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:200. Number of Islands]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[题目描述 1Given a 2d grid map of &apos;1&apos;s (land) and &apos;0&apos;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 这题需要一个额外的二维数组，来记录某一个点是否被检查过。然后我们需要对所有的点按顺序进行一次深度优先搜索，如果说这个点已经被检查过，则不再搜索。那么，一开始需要进行搜索的点的个数，就是岛屿的数量。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def __init__(self): self.count = 0 self.matrix = None def numIslands(self, grid: 'list[list[str]]') -&gt; 'int': if len(grid) == 0: return 0 if len(grid[0]) == 0: return 0 self.matrix = [[0] * len(grid[0]) for _ in range(len(grid))] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1' and self.matrix[i][j] == 0: self.count += 1 self.dfs(i, j, grid) return self.count def dfs(self, x, y, grid): if grid[x][y] == '1': self.matrix[x][y] = 1 if x &gt; 0 and self.matrix[x-1][y] == 0: self.dfs(x-1, y, grid) if y &gt; 0 and self.matrix[x][y-1] == 0: self.dfs(x, y-1, grid) if x &lt; len(grid)-1 and self.matrix[x+1][y] == 0: self.dfs(x+1, y, grid) if y &lt; len(grid[0])-1 and self.matrix[x][y+1] == 0: self.dfs(x, y+1, grid)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:199. Binary Tree Right Side View]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目描述 1Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. 这题很像之前的按照行来对树进行遍历，就是用一个类似先用一个queue来存放头节点，对queue中的所有元素的left和right进行检查，如果不是None的话就存放到另一个tmp_queue中，直到遍历完queue中的所有元素为止。接着把tmp_queue赋值给queue，进行新的一层的遍历。 所以只需要记录每一次的tmp_queue的最后一个元素即可。 代码实现 1234567891011121314151617181920class Solution: def rightSideView(self, root: 'TreeNode') -&gt; 'list[int]': result = [] if root == None: return result queue = [root] result.append(root.val) while len(queue) &gt; 0: tmp = [] for i in queue: if i.left != None: tmp.append(i.left) if i.right != None: tmp.append(i.right) if len(tmp) &gt; 0: result.append(tmp[-1].val) queue = tmp return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:198. House Robber]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[题目描述 123You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 这题就是一个很明显的动态规划。由于两次偷盗的索引不能相邻，因此某个索引的偷盗最大值为上个索引的偷盗最大值或上上个索引的偷盗值加上当前nums的值，即dp[i] = max(dp[i-1], dp[i-2] + nums[i]) 代码实现 1234567891011121314class Solution: def rob(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 dp = [0] * len(nums) dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(dp)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:174. Dungeon Game]]></title>
    <url>%2F2019%2F06%2F19%2FLeetCode-174-Dungeon-Game%2F</url>
    <content type="text"><![CDATA[题目概述 123456789The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0&apos;s) or contain magic orbs that increase the knight&apos;s health (positive integers).In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.Write a function to determine the knight&apos;s minimum initial health so that he is able to rescue the princess. 这道题目翻译一下，就是要保证这个骑士在走过每一个格子之后，血量至少为1。这题可以用动态规划来进行求解。如果一个格子上的数字为-5，那么骑士在踏上这个格子的时候，至少需要max(1, 1-(-5)) = 6点血量；如果格子上的数字为5，那么骑士只需要max(1, 1-5) = 1点血量。 接着需要考虑周围格子的情况。如果某个格子的右边的格子至少需要有4点血量，另一个格子至少要3点血量，那么在经过这个格子之后，我们需要至少保留min(4, 3) = 3点血量。 那么，状态转移公式就是dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) 代码实现 12345678910111213141516171819class Solution: def calculateMinimumHP(self, dungeon: 'list[list[int]]') -&gt; 'int': row = len(dungeon) column = len(dungeon[0]) dp = [[0] * column for _ in range(row)] dp[row-1][column-1] = max(1 - dungeon[row-1][column-1], 1) for i in range(column-2, -1, -1): dp[row-1][i] = max(dp[row-1][i+1] - dungeon[row-1][i], 1) for i in range(row - 2, -1, -1): dp[i][column - 1] = max(dp[i + 1][column - 1] - dungeon[i][column - 1], 1) for i in range(row - 2, -1, -1): for j in range(column - 2, -1, -1): dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1) return dp[0][0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:173. Binary Search Tree Iterator]]></title>
    <url>%2F2019%2F06%2F17%2FLeetCode-173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[题目概述 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. 这题我使用了一个DFS来遍历BST，并且把按顺序把树的节点存到了self.nodes的list中。这个类同时还保存了一个当前对象在self.nodes的索引值，如果使用了next方法，就把这个索引值加一，hasnext则判断这个索引值和self.nodes的长度的关系 代码实现 12345678910111213141516171819202122232425262728class BSTIterator: def __init__(self, root: TreeNode): self.nodes = [] self.dfs(root) self.index = -1 def next(self) -&gt; int: """ @return the next smallest number """ self.index += 1 return self.nodes[self.index].val def hasNext(self) -&gt; bool: """ @return whether we have a next smallest number """ if self.index &lt; len(self.nodes) - 1: return True else: return False def dfs(self, root): if root == None: return self.dfs(root.left) self.nodes.append(root) self.dfs(root.right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:172. Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer n, return the number of trailing zeroes in n!. 在阶乘中，只有5的倍数能产生0，因此这道题就转化成了n!的因子中有多少个5. 这里需要注意的是，25，125这种数字包含了多个5，需要进行重复计算。 代码实现 12345678class Solution: def trailingZeroes(self, n: int) -&gt; int: divisor = 5 result = 0 while divisor &lt;= n: result += n // divisor divisor *= 5 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:171. Excel Sheet Column Number]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-171-Excel-Sheet-Column-Number%2F</url>
    <content type="text"><![CDATA[题目概述 Given a column title as appear in an Excel sheet, return its corresponding column number. 进制转换的题目 代码实现 12345678class Solution: def titleToNumber(self, s: 'str') -&gt; 'int': result = 0 for i in range(len(s)): result *= 26 result += ord(s[i]) - 64 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:169. Majority Element]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-169-Majority-Element%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 题目要求找到数组中的众数。我是把数组进行排序后从左到右找，如果当前数字和之前的数字一样，就会给一个记录值加一，如果发现当前数字与其之前的数字不一样，则把记录值和全局最大值进行比较。 代码实现 123456789101112131415161718192021class Solution: def majorityElement(self, nums: 'list[int]') -&gt; 'int': nums = sorted(nums) if len(nums) == 1: return nums[0] maxNum = 1 tmpNum = 1 targetIndex = 0 for i in range(1, len(nums)): if nums[i] == nums[i-1]: tmpNum += 1 elif i &lt; len(nums): if tmpNum &gt;= maxNum: targetIndex = i-1 maxNum = tmpNum tmpNum = 1 if i == len(nums)-1 and tmpNum &gt;= maxNum: targetIndex = i return nums[targetIndex]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:168. Excel Sheet Column Title]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode-168-Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[题目概述 Given a positive integer, return its corresponding column title as appear in an Excel sheet. 进制转换的题目 代码实现 1234567891011class Solution: def convertToTitle(self, n: 'int') -&gt; 'str': result = "" while True: remainder = (n-1) % 26 n = int((n-1)/26) result = chr(65+remainder) + result if n == 0: break return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. 简单题，由于数组是递增的，所以一开始假定index1为0，index2为数组的最后一个索引，如果对应的两个数相加比target小，则让index1加一，反之让index2减1，直到找到两个和为target的值的索引 最后注意把求得的index+1即可。 代码实现 123456789101112class Solution: def twoSum(self, numbers: 'list[int]', target: 'int') -&gt; 'list[int]': index1 = 0 index2 = len(numbers) - 1 while numbers[index1] + numbers[index2] != target: if numbers[index1] + numbers[index2] &gt; target: index2 -= 1 else: index1 += 1 return [index1+1, index2+1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:166. Fraction to Recurring Decimal]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[题目概述 Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. 本题的难点就在如何找到无限循环小数的循环体。 以5/3为例：5/3的整数部分为int(5/3)也就是1，余数为2，然后计算小数点1位之后的数字时，实际上是把2乘以了10，也就是20再除以3，得到了6，余2。这里的6就是小数点后1位的数字。接着，再用余数2*10/3…以此类推。所以说，我们只需要一个数组，存放每一次进行除法操作后的余数，如果余数相同，则已经开始循环了。 在实现的时候，我使用的是数组而不是哈希表，主要还是因为题目需要在结果字符串中添加括号，使用数组更容易对括号的地方进行定位。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def fractionToDecimal(self, numerator: 'int', denominator: 'int') -&gt; 'str': sign = 1 if numerator/denominator &gt;= 0 else -1 numerator = abs(numerator) denominator = abs(denominator) remainder = numerator % denominator if remainder == 0: return str(int(sign * numerator / denominator)) result = "-" if sign == -1 else "" result += str(int(numerator/denominator)) result += '.' remainderList = [] while True: if remainder == 0: return result if remainder in remainderList: for i in range(len(remainderList)): if remainderList[i] == remainder: insertIndex = len(remainderList) - i resultList = list(result) resultList.insert(-insertIndex, '(') resultList.append(')') result = "".join(resultList) return result else: remainderList.append(remainder) remainder *= 10 result += str(int(remainder / denominator)) remainder = remainder % denominator]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:165. Compare Version Numbers]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[题目概述 Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. 这题其实不难，本质上就是把字符串根据’.’进行切割后形成两个数组，然后对两个数组的元素进行逐一比较即可。 代码实现 1234567891011121314151617181920212223class Solution: def compareVersion(self, version1: 'str', version2: 'str') -&gt; 'int': list1 = version1.split('.') list2 = version2.split('.') maxNum = min(len(list1), len(list2)) for i in range(maxNum): if int(list1[i]) &gt; int(list2[i]): return 1 elif int(list1[i]) &lt; int(list2[i]): return -1 if len(list1) &gt; len(list2): for i in range(maxNum, len(list1)): if int(list1[i]) &gt; 0: return 1 return 0 elif len(list1) == len(list2): return 0 else: for i in range(maxNum, len(list2)): if int(list2[i]) &gt; 0: return -1 return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:164. Maximum Gap]]></title>
    <url>%2F2019%2F06%2F14%2FLeetCode-164-Maximum-Gap%2F</url>
    <content type="text"><![CDATA[题目概述 Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. 本题最难的地方就是要求时间和空间复杂度都为O(n) 所以本题的思路就是使用桶排序，因为这是一种时间复杂度和空间复杂度都为O(n)的排序算法。但是本题要求的不仅是排序，还需要算出数与数之间最大的Gap。 参考了网上的一些做法后，我也逐渐理清了思路。 首先，这个最大gap的值，不可能小于(maxNum-minNum)/size的值，其中maxNum和minNum为数组中的最大值和最小值，而size则为输入的数组大小。 考虑到这点，我们就可以用size+1个桶来存放nums中的所有数字。每个桶的大小为(maxNum-minNum)/size，存放的桶的索引值则为(i-minNum)/size。这样，我们就只需要找到每个桶的最大值和最小值，并且来比较桶与桶之间的最大Gap，这个最大Gap就是整个数组的最大Gap。（因为桶内的两个数的最大Gap不可能成为全局最大Gap） 由于不需要进行数与数之间的比较，本算法的时间复杂度和空间复杂度都是线性的。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) &#123; return 0; &#125; int maxNum = INT_MIN; int minNum = INT_MAX; for (auto i:nums) &#123; if (i &lt; minNum) &#123; minNum = i; &#125; if (i &gt; maxNum) &#123; maxNum = i; &#125; &#125; if (maxNum == minNum) return 0; int len = nums.size(); int bucketSize = ceil((double)(maxNum-minNum)/nums.size()); int bucketNum = nums.size()+1; vector&lt;vector&lt;int&gt;&gt; bucket(bucketNum); for (auto i:bucket) &#123; i.resize(0); &#125; for (auto i:nums) &#123; int index = (i-minNum)/bucketSize; bucket[index].push_back(i); &#125; int result = INT_MIN; vector&lt;bool&gt; isValid(bucketNum); vector&lt;int&gt; bucketMin(bucketNum); vector&lt;int&gt; bucketMax(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; if (bucket[i].size() &gt; 0)&#123; isValid[i] = true; int tmpMin = INT_MAX; int tmpMax = INT_MIN; for (int j = 0; j &lt; bucket[i].size(); j++)&#123; if (bucket[i][j] &lt; tmpMin) tmpMin = bucket[i][j]; if (bucket[i][j] &gt; tmpMax) tmpMax = bucket[i][j]; &#125; bucketMin[i] = tmpMin; bucketMax[i] = tmpMax; &#125; else &#123; isValid[i] = false; &#125; &#125; int lastMax = bucketMax[0]; for (int i = 1; i &lt; bucketNum; i++) &#123; if (!isValid[i]) continue; result = result &gt; bucketMin[i] - lastMax ? result : bucketMin[i] - lastMax; lastMax = bucketMax[i]; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:160. Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目概述 Write a program to find the node at which the intersection of two singly linked lists begins. 本题的思路就是对两个链表进行从头到尾的遍历，并且将所得的地址存在两个vector中，然后从后往前比较vector，找到第一个不同的地址的索引，该索引+1就是两个链表的交点地址。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; vector&lt;struct ListNode *&gt; vector1; vector&lt;struct ListNode *&gt; vector2; while (headA != nullptr)&#123; vector1.push_back(headA); headA = headA-&gt;next; &#125; vector1.push_back(nullptr); while (headB != nullptr)&#123; vector2.push_back(headB); headB = headB-&gt;next; &#125; vector2.push_back(nullptr); int i = 1; int maxNum = vector1.size() &gt; vector2.size()? vector2.size(): vector1.size(); for (i = 1; i &lt;= maxNum; i++)&#123; if (vector1[vector1.size()-i] != vector2[vector2.size()-i])&#123; break; &#125; &#125; return vector1[vector1.size()-i+1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:155. Min Stack]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目概述 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. 本题的解法就是要实现两个栈。其中一个栈用来存放原数据信息，第二个栈用来存放当前栈的最小值。第二个栈的栈顶是当前栈的最小值。在进行push和pop的时候，对第一个栈进行常规操作，当push的值小于第二个栈的栈顶时，要将该值也push进第二个栈；如果pop出的值为第二个栈的栈顶元素时，也需要对第二个栈进行pop操作。 代码实现 1234567891011121314151617181920212223242526272829303132333435class MinStack &#123;private: stack&lt;int&gt; itemStack; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if (minStack.empty() || minStack.top() &gt;= x)&#123; itemStack.push(x); minStack.push(x); &#125; else &#123; itemStack.push(x); &#125; &#125; void pop() &#123; if (itemStack.top() == minStack.top())&#123; itemStack.pop(); minStack.pop(); &#125; else &#123; itemStack.pop(); &#125; &#125; int top() &#123; return itemStack.top(); &#125; int getMin() &#123; return minStack.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. 同理LeetCode: 153. Find Minimum in Rotated Sorted Array 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. 由于输入的数组是通过有序的数组进行旋转后得到的，因此在从左向右遍历的时候，突然变小的那个数字一定是全局最小值 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:152. Maximum Product Subarray]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-152-Maximum-Product-Subarray%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. 本题和之前求连续子序列的最大和的那题很像。但是乘法与加法不同，还需要考虑两个负数的乘积很大的情况。 在这里，我用的解法是动态规划。对于序列nums，为了求解出最大的连续子序列的最大乘积，需要维护三个数组，分别为max_local, min_local和max_global。max_local[i]的含义是，以索引为i结束的连续子序列的乘积最大值；min_local[i]的含义是，以索引为i结束的连续子序列的乘积最小值，max_global[i]为到索引i为止，全局的乘积最大值。其中max_local[0], min_local[0]以及max_global[0]都为nums[0]。动态规划的状态转移公式为： 123max_local[i] = max(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])min_local[i] = min(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])max_global[i] = max(max_local[i], max_global[i-1]) 代码实现 12345678910111213141516171819class Solution: def maxProduct(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 max_local = [0] * len(nums) min_local = [0] * len(nums) max_global = [0] * len(nums) max_local[0] = nums[0] min_local[0] = nums[0] max_global[0] = nums[0] for i in range(1, len(nums)): max_local[i] = max(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) min_local[i] = min(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) max_global[i] = max(max_global[i-1], max_local[i]) return max_global[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:151. Reverse Words in a String]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[题目概述 Given an input string, reverse the string word by word. 本题用python实现的话其实挺简单的，直接用strip和split方法就可以 代码实现 1234567891011class Solution: def reverseWords(self, s: str) -&gt; str: s = s.strip() s_list = s.split(" ") result = "" for i in range(len(s_list)-1, -1, -1): if s_list[i] == "": continue result += " "+s_list[i] return result[1:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[题目概述 Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. 本题就是要实现一个简单的stack，当输入为数字的时候进行push操作，对于操作符则需要pop出两个数字，并且进行计算，最后返回stack中的唯一元素即可。 代码实现 12345678910111213141516171819202122232425262728class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for item in tokens: if item == "+": num1 = stack.pop() num2 = stack.pop() stack.append(num1+num2) elif item == "-": num1 = stack.pop() num2 = stack.pop() stack.append(num2-num1) elif item == "*": num1 = stack.pop() num2 = stack.pop() stack.append(num1*num2) elif item == "/": num1 = stack.pop() num2 = stack.pop() stack.append(int(num2/num1)) else: stack.append(int(item)) return stack[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:149. Max Points on a Line]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[题目概述 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 这题比较坑，而且这个hard难度考察的也并不是算法。这题目最直观的想法是通过求两点的直线方程后，对所有点进行遍历并记数。我们需要求到两点之间的斜率等信息。 但是，本题要考虑的还有： 如何尽量避免重复的运算 对平行于Y轴的直线的特殊处理 需要考虑除法带来的一些计算问题：计算机内部的除法得到的值并非是一个分数，而是一个有限小数。比如对于[1,1]、[4,2]两点，通过求解得到的斜率不是正好的1/3，而是类似0.33333的有限小数，因此尽管点[7,3]在这条直线上，但是使用0.33333*(7-1)+1-3得到的并不是0，而是一个很接近0的数字，因此需要尽量避免使用除法 因此，在本题中，我使用了checkMetrix来表示两个点之间是否已经经过了计算，并且使用乘法代替除法 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def __init__(self): self.checkMetrix = None def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ wordLen = len(points) self.checkMetrix = [[0] * wordLen for _ in range(wordLen)] maxCount = 0 flag = 0 for i in range(wordLen): for j in range(wordLen): if self.checkMetrix[i][j] == 1: continue if i == j: continue if points[i][0] == points[j][0] and points[i][1] == points[j][1]: continue maxCount = max(self.countPoints(i, j, points), maxCount) flag = 1 if flag == 0: return wordLen else: return maxCount def countPoints(self, index1, index2, points): point1 = points[index1] point2 = points[index2] count = 0 if point1[0] == point2[0]: for i in range(len(points)): if points[i][0] == point1[0]: self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 else: for i in range(len(points)): if (point1[1] - point2[1]) * (points[i][0]-point1[0]) == (points[i][1] - point1[1]) * (point1[0] - point2[0]): self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 return count l]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
