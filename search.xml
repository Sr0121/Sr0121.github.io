<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:149. Max Points on a Line]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[题目概述 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 这题比较坑，而且这个hard难度考察的也并不是算法。这题目最直观的想法是通过求两点的直线方程后，对所有点进行遍历并记数。我们需要求到两点之间的斜率等信息。 但是，本题要考虑的还有： 如何尽量避免重复的运算 对平行于Y轴的直线的特殊处理 需要考虑除法带来的一些计算问题：计算机内部的除法得到的值并非是一个分数，而是一个有限小数。比如对于[1,1]、[4,2]两点，通过求解得到的斜率不是正好的1/3，而是类似0.33333的有限小数，因此尽管点[7,3]在这条直线上，但是使用0.33333*(7-1)+1-3得到的并不是0，而是一个很接近0的数字，因此需要尽量避免使用除法 因此，在本题中，我使用了checkMetrix来表示两个点之间是否已经经过了计算，并且使用乘法代替除法 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def __init__(self): self.checkMetrix = None def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ wordLen = len(points) self.checkMetrix = [[0] * wordLen for _ in range(wordLen)] maxCount = 0 flag = 0 for i in range(wordLen): for j in range(wordLen): if self.checkMetrix[i][j] == 1: continue if i == j: continue if points[i][0] == points[j][0] and points[i][1] == points[j][1]: continue maxCount = max(self.countPoints(i, j, points), maxCount) flag = 1 if flag == 0: return wordLen else: return maxCount def countPoints(self, index1, index2, points): point1 = points[index1] point2 = points[index2] count = 0 if point1[0] == point2[0]: for i in range(len(points)): if points[i][0] == point1[0]: self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 else: for i in range(len(points)): if (point1[1] - point2[1]) * (points[i][0]-point1[0]) == (points[i][1] - point1[1]) * (point1[0] - point2[0]): self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 return count l]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
