<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[题目概述 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. 简单题，由于数组是递增的，所以一开始假定index1为0，index2为数组的最后一个索引，如果对应的两个数相加比target小，则让index1加一，反之让index2减1，直到找到两个和为target的值的索引 最后注意把求得的index+1即可。 代码实现 123456789101112class Solution: def twoSum(self, numbers: 'list[int]', target: 'int') -&gt; 'list[int]': index1 = 0 index2 = len(numbers) - 1 while numbers[index1] + numbers[index2] != target: if numbers[index1] + numbers[index2] &gt; target: index2 -= 1 else: index1 += 1 return [index1+1, index2+1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:166. Fraction to Recurring Decimal]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[题目概述 Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. 本题的难点就在如何找到无限循环小数的循环体。 以5/3为例：5/3的整数部分为int(5/3)也就是1，余数为2，然后计算小数点1位之后的数字时，实际上是把2乘以了10，也就是20再除以3，得到了6，余2。这里的6就是小数点后1位的数字。接着，再用余数2*10/3…以此类推。所以说，我们只需要一个数组，存放每一次进行除法操作后的余数，如果余数相同，则已经开始循环了。 在实现的时候，我使用的是数组而不是哈希表，主要还是因为题目需要在结果字符串中添加括号，使用数组更容易对括号的地方进行定位。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution: def fractionToDecimal(self, numerator: 'int', denominator: 'int') -&gt; 'str': sign = 1 if numerator/denominator &gt;= 0 else -1 numerator = abs(numerator) denominator = abs(denominator) remainder = numerator % denominator if remainder == 0: return str(int(sign * numerator / denominator)) result = "-" if sign == -1 else "" result += str(int(numerator/denominator)) result += '.' remainderList = [] while True: if remainder == 0: return result if remainder in remainderList: for i in range(len(remainderList)): if remainderList[i] == remainder: insertIndex = len(remainderList) - i resultList = list(result) resultList.insert(-insertIndex, '(') resultList.append(')') result = "".join(resultList) return result else: remainderList.append(remainder) remainder *= 10 result += str(int(remainder / denominator)) remainder = remainder % denominator]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:165. Compare Version Numbers]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[题目概述 Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. 这题其实不难，本质上就是把字符串根据’.’进行切割后形成两个数组，然后对两个数组的元素进行逐一比较即可。 代码实现 1234567891011121314151617181920212223class Solution: def compareVersion(self, version1: 'str', version2: 'str') -&gt; 'int': list1 = version1.split('.') list2 = version2.split('.') maxNum = min(len(list1), len(list2)) for i in range(maxNum): if int(list1[i]) &gt; int(list2[i]): return 1 elif int(list1[i]) &lt; int(list2[i]): return -1 if len(list1) &gt; len(list2): for i in range(maxNum, len(list1)): if int(list1[i]) &gt; 0: return 1 return 0 elif len(list1) == len(list2): return 0 else: for i in range(maxNum, len(list2)): if int(list2[i]) &gt; 0: return -1 return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:164. Maximum Gap]]></title>
    <url>%2F2019%2F06%2F14%2FLeetCode-164-Maximum-Gap%2F</url>
    <content type="text"><![CDATA[题目概述 Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. 本题最难的地方就是要求时间和空间复杂度都为O(n) 所以本题的思路就是使用桶排序，因为这是一种时间复杂度和空间复杂度都为O(n)的排序算法。但是本题要求的不仅是排序，还需要算出数与数之间最大的Gap。 参考了网上的一些做法后，我也逐渐理清了思路。 首先，这个最大gap的值，不可能小于(maxNum-minNum)/size的值，其中maxNum和minNum为数组中的最大值和最小值，而size则为输入的数组大小。 考虑到这点，我们就可以用size+1个桶来存放nums中的所有数字。每个桶的大小为(maxNum-minNum)/size，存放的桶的索引值则为(i-minNum)/size。这样，我们就只需要找到每个桶的最大值和最小值，并且来比较桶与桶之间的最大Gap，这个最大Gap就是整个数组的最大Gap。（因为桶内的两个数的最大Gap不可能成为全局最大Gap） 由于不需要进行数与数之间的比较，本算法的时间复杂度和空间复杂度都是线性的。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) &#123; return 0; &#125; int maxNum = INT_MIN; int minNum = INT_MAX; for (auto i:nums) &#123; if (i &lt; minNum) &#123; minNum = i; &#125; if (i &gt; maxNum) &#123; maxNum = i; &#125; &#125; if (maxNum == minNum) return 0; int len = nums.size(); int bucketSize = ceil((double)(maxNum-minNum)/nums.size()); int bucketNum = nums.size()+1; vector&lt;vector&lt;int&gt;&gt; bucket(bucketNum); for (auto i:bucket) &#123; i.resize(0); &#125; for (auto i:nums) &#123; int index = (i-minNum)/bucketSize; bucket[index].push_back(i); &#125; int result = INT_MIN; vector&lt;bool&gt; isValid(bucketNum); vector&lt;int&gt; bucketMin(bucketNum); vector&lt;int&gt; bucketMax(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; if (bucket[i].size() &gt; 0)&#123; isValid[i] = true; int tmpMin = INT_MAX; int tmpMax = INT_MIN; for (int j = 0; j &lt; bucket[i].size(); j++)&#123; if (bucket[i][j] &lt; tmpMin) tmpMin = bucket[i][j]; if (bucket[i][j] &gt; tmpMax) tmpMax = bucket[i][j]; &#125; bucketMin[i] = tmpMin; bucketMax[i] = tmpMax; &#125; else &#123; isValid[i] = false; &#125; &#125; int lastMax = bucketMax[0]; for (int i = 1; i &lt; bucketNum; i++) &#123; if (!isValid[i]) continue; result = result &gt; bucketMin[i] - lastMax ? result : bucketMin[i] - lastMax; lastMax = bucketMax[i]; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:160. Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目概述 Write a program to find the node at which the intersection of two singly linked lists begins. 本题的思路就是对两个链表进行从头到尾的遍历，并且将所得的地址存在两个vector中，然后从后往前比较vector，找到第一个不同的地址的索引，该索引+1就是两个链表的交点地址。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; vector&lt;struct ListNode *&gt; vector1; vector&lt;struct ListNode *&gt; vector2; while (headA != nullptr)&#123; vector1.push_back(headA); headA = headA-&gt;next; &#125; vector1.push_back(nullptr); while (headB != nullptr)&#123; vector2.push_back(headB); headB = headB-&gt;next; &#125; vector2.push_back(nullptr); int i = 1; int maxNum = vector1.size() &gt; vector2.size()? vector2.size(): vector1.size(); for (i = 1; i &lt;= maxNum; i++)&#123; if (vector1[vector1.size()-i] != vector2[vector2.size()-i])&#123; break; &#125; &#125; return vector1[vector1.size()-i+1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:155. Min Stack]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目概述 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. 本题的解法就是要实现两个栈。其中一个栈用来存放原数据信息，第二个栈用来存放当前栈的最小值。第二个栈的栈顶是当前栈的最小值。在进行push和pop的时候，对第一个栈进行常规操作，当push的值小于第二个栈的栈顶时，要将该值也push进第二个栈；如果pop出的值为第二个栈的栈顶元素时，也需要对第二个栈进行pop操作。 代码实现 1234567891011121314151617181920212223242526272829303132333435class MinStack &#123;private: stack&lt;int&gt; itemStack; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if (minStack.empty() || minStack.top() &gt;= x)&#123; itemStack.push(x); minStack.push(x); &#125; else &#123; itemStack.push(x); &#125; &#125; void pop() &#123; if (itemStack.top() == minStack.top())&#123; itemStack.pop(); minStack.pop(); &#125; else &#123; itemStack.pop(); &#125; &#125; int top() &#123; return itemStack.top(); &#125; int getMin() &#123; return minStack.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. 同理LeetCode: 153. Find Minimum in Rotated Sorted Array 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F12%2FLeetCode-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目概述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. 由于输入的数组是通过有序的数组进行旋转后得到的，因此在从左向右遍历的时候，突然变小的那个数字一定是全局最小值 代码实现 123456class Solution: def findMin(self, nums: 'list[int]') -&gt; 'int': for i in range(1, len(nums)): if nums[i] &lt; nums[i-1]: return nums[i] return nums[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:152. Maximum Product Subarray]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-152-Maximum-Product-Subarray%2F</url>
    <content type="text"><![CDATA[题目概述 Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. 本题和之前求连续子序列的最大和的那题很像。但是乘法与加法不同，还需要考虑两个负数的乘积很大的情况。 在这里，我用的解法是动态规划。对于序列nums，为了求解出最大的连续子序列的最大乘积，需要维护三个数组，分别为max_local, min_local和max_global。max_local[i]的含义是，以索引为i结束的连续子序列的乘积最大值；min_local[i]的含义是，以索引为i结束的连续子序列的乘积最小值，max_global[i]为到索引i为止，全局的乘积最大值。其中max_local[0], min_local[0]以及max_global[0]都为nums[0]。动态规划的状态转移公式为： 123max_local[i] = max(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])min_local[i] = min(max_local[i-1]*nums[i], min_local[i-1]*nums[i], nums[i])max_global[i] = max(max_local[i], max_global[i-1]) 代码实现 12345678910111213141516171819class Solution: def maxProduct(self, nums: 'list[int]') -&gt; 'int': if len(nums) == 0: return 0 max_local = [0] * len(nums) min_local = [0] * len(nums) max_global = [0] * len(nums) max_local[0] = nums[0] min_local[0] = nums[0] max_global[0] = nums[0] for i in range(1, len(nums)): max_local[i] = max(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) min_local[i] = min(max_local[i-1] * nums[i], min_local[i-1] * nums[i], nums[i]) max_global[i] = max(max_global[i-1], max_local[i]) return max_global[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:151. Reverse Words in a String]]></title>
    <url>%2F2019%2F06%2F11%2FLeetCode-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[题目概述 Given an input string, reverse the string word by word. 本题用python实现的话其实挺简单的，直接用strip和split方法就可以 代码实现 1234567891011class Solution: def reverseWords(self, s: str) -&gt; str: s = s.strip() s_list = s.split(" ") result = "" for i in range(len(s_list)-1, -1, -1): if s_list[i] == "": continue result += " "+s_list[i] return result[1:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[题目概述 Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. 本题就是要实现一个简单的stack，当输入为数字的时候进行push操作，对于操作符则需要pop出两个数字，并且进行计算，最后返回stack中的唯一元素即可。 代码实现 12345678910111213141516171819202122232425262728class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for item in tokens: if item == "+": num1 = stack.pop() num2 = stack.pop() stack.append(num1+num2) elif item == "-": num1 = stack.pop() num2 = stack.pop() stack.append(num2-num1) elif item == "*": num1 = stack.pop() num2 = stack.pop() stack.append(num1*num2) elif item == "/": num1 = stack.pop() num2 = stack.pop() stack.append(int(num2/num1)) else: stack.append(int(item)) return stack[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:149. Max Points on a Line]]></title>
    <url>%2F2019%2F06%2F10%2FLeetCode-149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[题目概述 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 这题比较坑，而且这个hard难度考察的也并不是算法。这题目最直观的想法是通过求两点的直线方程后，对所有点进行遍历并记数。我们需要求到两点之间的斜率等信息。 但是，本题要考虑的还有： 如何尽量避免重复的运算 对平行于Y轴的直线的特殊处理 需要考虑除法带来的一些计算问题：计算机内部的除法得到的值并非是一个分数，而是一个有限小数。比如对于[1,1]、[4,2]两点，通过求解得到的斜率不是正好的1/3，而是类似0.33333的有限小数，因此尽管点[7,3]在这条直线上，但是使用0.33333*(7-1)+1-3得到的并不是0，而是一个很接近0的数字，因此需要尽量避免使用除法 因此，在本题中，我使用了checkMetrix来表示两个点之间是否已经经过了计算，并且使用乘法代替除法 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def __init__(self): self.checkMetrix = None def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ wordLen = len(points) self.checkMetrix = [[0] * wordLen for _ in range(wordLen)] maxCount = 0 flag = 0 for i in range(wordLen): for j in range(wordLen): if self.checkMetrix[i][j] == 1: continue if i == j: continue if points[i][0] == points[j][0] and points[i][1] == points[j][1]: continue maxCount = max(self.countPoints(i, j, points), maxCount) flag = 1 if flag == 0: return wordLen else: return maxCount def countPoints(self, index1, index2, points): point1 = points[index1] point2 = points[index2] count = 0 if point1[0] == point2[0]: for i in range(len(points)): if points[i][0] == point1[0]: self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 else: for i in range(len(points)): if (point1[1] - point2[1]) * (points[i][0]-point1[0]) == (points[i][1] - point1[1]) * (point1[0] - point2[0]): self.checkMetrix[i][index1] = 1 self.checkMetrix[i][index2] = 1 self.checkMetrix[index1][i] = 1 self.checkMetrix[index2][i] = 1 count += 1 return count l]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:148. Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list in O(n log n) time using constant space complexity. 这是一道挺好的题目，第一眼给人的感觉非常简单，就是实现一个快速排序。但是实际上，链表的快速排序和数组的快速排序差别还是很大的。其中最重要的地方就是要在实现递归的快速排序的同时，保证链表的完整性，即所有Nodes需要传成一条链，并且保证你能访问到这条链的头节点。这就需要实现快速排序的方法能够将头节点进行传出。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; return this-&gt;quickSort(head, nullptr); &#125;private: ListNode* quickSort(ListNode* start, ListNode* end)&#123; if (start == nullptr)&#123; return nullptr; &#125; int standard = start-&gt;val; ListNode* leftStart = new ListNode(-1); ListNode* leftTail = leftStart; ListNode* rightStart = new ListNode(-1); ListNode* rightTail = rightStart; ListNode* checkNode = start-&gt;next; while (checkNode != end)&#123; if (checkNode-&gt;val &lt;= standard)&#123; leftTail-&gt;next = checkNode; leftTail = leftTail-&gt;next; &#125; else &#123; rightTail-&gt;next = checkNode; rightTail = rightTail-&gt;next; &#125; ListNode* saveCheckNode = checkNode; checkNode = checkNode-&gt;next; saveCheckNode-&gt;next = nullptr; &#125; leftStart-&gt;next = this-&gt;quickSort(leftStart-&gt;next, end); rightStart-&gt;next = this-&gt;quickSort(rightStart-&gt;next, end); leftTail = leftStart; while (leftTail-&gt;next != nullptr)&#123; leftTail = leftTail-&gt;next; &#125; leftTail-&gt;next = start; start-&gt;next = rightStart-&gt;next; return leftStart-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:147. Insertion Sort List]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[题目概述 Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list 本题本质上是一个水题，就是简单的插入排序，只是使用了链表来进行处理。只需要将普通的数组插入排序对数组的遍历操作改成对链表的遍历即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == nullptr) return head; ListNode *ori = new ListNode(-2147483648); ori-&gt;next = head; ListNode *last = ori; ListNode *current = head; while (current != nullptr) &#123; if (current-&gt;val &gt;= last-&gt;val) &#123; current = current-&gt;next; last = last-&gt;next; &#125; else &#123; ListNode *saveNext = current-&gt;next; ListNode *start = ori; while (start-&gt;next-&gt;val &lt;= current-&gt;val) start = start-&gt;next; current-&gt;next = start-&gt;next; start-&gt;next = current; last-&gt;next = saveNext; current = saveNext; &#125; &#125; last-&gt;next = nullptr; return ori-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:146. LRU Cache]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目概述 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. 本题本质上就是模拟cache的替换策略。当cache没有满时进行put操作会直接按顺序将cache填充满，如果cache满后进行put操作，将会替代掉最先使用的key的信息。 所以本题就是维护一个数组keys，这个数组的最左边的key为最先使用的key，最右边则为最近使用的key。同时，还需要用一个keyMap来存放所有key对应的value值。我令所有的key最初为-1，在进行put(key, value)操作时： 如果数组keys中存在这个key时，把这个key右边的所有信息左移一格。然后在所有有效信息（非-1信息）的最右边加上这个key，保证数组能够存储keys的使用先后信息 如果keys中不存在这个key，并且keys数组没有满，则在所有有效信息的最右边加上这个key 如果keys中不存在这个key，并且keys数组已满，则将最左边的key删除，把所有的key向左移动一格，最后在最右边加上这个key 在进行get(key)操作时候： 如果keys不存在这个key，则返回-1 如果keys存在这个key，按照put才做中的1来操作keys数组，并且在keyMap中查找对应的值进行返回 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;keys = (int*)malloc(sizeof(int)*capacity); for (int i = 0; i &lt; capacity; i++) &#123; this-&gt;keys[i] = -1; &#125; this-&gt;capacity = capacity; &#125; int get(int key) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key)&#123; this-&gt;modify(i, key); return this-&gt;keyMap[key]; &#125; &#125; return -1; &#125; void put(int key, int value) &#123; for (int i = 0; i &lt; this-&gt;capacity; i++)&#123; if (this-&gt;keys[i] == key) &#123; this-&gt;keyMap[key] = value; this-&gt;modify(i, key); return; &#125; if (this-&gt;keys[i] == -1) &#123; this-&gt;keyMap[key] = value; this-&gt;keys[i] = key; return; &#125; &#125; this-&gt;keyMap.erase(this-&gt;keys[0]); this-&gt;keyMap[key] = value; this-&gt;add(key); &#125;private: int *keys; int capacity; map&lt;int, int&gt; keyMap; void modify(int index, int key)&#123; int i; for(i = index; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; if (this-&gt;keys[i] == -1) &#123; this-&gt;keys[i] = key; return; &#125; &#125; if (i == capacity-1)&#123; this-&gt;keys[i] = key; &#125; &#125; void add(int key)&#123; for(int i = 0; i &lt; this-&gt;capacity-1; i++)&#123; this-&gt;keys[i] = this-&gt;keys[i+1]; &#125; this-&gt;keys[this-&gt;capacity-1] = key; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
